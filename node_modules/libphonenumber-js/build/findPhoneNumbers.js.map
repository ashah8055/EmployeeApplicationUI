{"version":3,"sources":["../source/findPhoneNumbers.js"],"names":["findPhoneNumbers","searchPhoneNumbers","sort_out_arguments","VALID_PHONE_NUMBER","EXTN_PATTERNS_FOR_PARSING","WHITESPACE_IN_THE_BEGINNING_PATTERN","RegExp","PUNCTUATION_IN_THE_END_PATTERN","VALID_PRECEDING_CHARACTER_PATTERN","arg_1","arg_2","arg_3","arg_4","text","options","metadata","search","PhoneNumberSearch","phones","hasNext","push","next","Symbol","iterator","done","value","state","regexp","matches","exec","number","startsAt","index","replace","length","result","parseCandidate","find","extended","phone","endsAt","last_match","Error","TypeError","defaultCountry"],"mappings":"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","file":"findPhoneNumbers.js","sourcesContent":["import parse from './parse'\r\nimport Metadata from './metadata'\r\n\r\nimport\r\n{\r\n\tPLUS_CHARS,\r\n\tVALID_PUNCTUATION,\r\n\tVALID_DIGITS,\r\n\tWHITESPACE,\r\n\tcreate_extension_pattern\r\n}\r\nfrom './common'\r\n\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\r\nimport isValidCandidate from './findNumbers/isValidCandidate'\r\n\r\n// Copy-pasted from `./parse.js`.\r\nconst VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\r\n\r\nconst WHITESPACE_IN_THE_BEGINNING_PATTERN = new RegExp('^[' + WHITESPACE + ']+')\r\nconst PUNCTUATION_IN_THE_END_PATTERN = new RegExp('[' + VALID_PUNCTUATION + ']+$')\r\n\r\n// // Regular expression for getting opening brackets for a valid number\r\n// // found using `PHONE_NUMBER_START_PATTERN` for prepending those brackets to the number.\r\n// const BEFORE_NUMBER_DIGITS_PUNCTUATION = new RegExp('[' + OPENING_BRACKETS + ']+' + '[' + WHITESPACE + ']*' + '$')\r\n\r\nconst VALID_PRECEDING_CHARACTER_PATTERN = /[^a-zA-Z0-9]/\r\n\r\nexport default function findPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\r\n\r\n\tconst phones = []\r\n\r\n\twhile (search.hasNext())\r\n\t{\r\n\t\tphones.push(search.next())\r\n\t}\r\n\r\n\treturn phones\r\n}\r\n\r\n/**\r\n * @return ES6 `for ... of` iterator.\r\n */\r\nexport function searchPhoneNumbers(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\tconst search = new PhoneNumberSearch(text, options, metadata.metadata)\r\n\r\n\treturn  {\r\n\t\t[Symbol.iterator]() {\r\n\t\t\treturn {\r\n\t    \t\tnext: () => {\r\n\t    \t\t\tif (search.hasNext()) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tdone: false,\r\n\t\t\t\t\t\t\tvalue: search.next()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdone: true\r\n\t\t\t\t\t}\r\n\t    \t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number including any opening brackets, etc.\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?startsAt, ?endsAt }`.\r\n */\r\nexport class PhoneNumberSearch\r\n{\r\n\t// Iteration tristate.\r\n\tstate = 'NOT_READY'\r\n\r\n\tconstructor(text, options = {}, metadata)\r\n\t{\r\n\t\tthis.text = text\r\n\t\tthis.options = options\r\n\t\tthis.metadata = metadata\r\n\r\n\t\tthis.regexp = new RegExp\r\n\t\t(\r\n\t\t\tVALID_PHONE_NUMBER +\r\n\t\t\t// Phone number extensions\r\n\t\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?',\r\n\t\t\t'ig'\r\n\t\t)\r\n\r\n\t\t// this.searching_from = 0\r\n\t}\r\n\r\n\tfind()\r\n\t{\r\n\t\tconst matches = this.regexp.exec(this.text)\r\n\r\n\t\tif (!matches) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet number   = matches[0]\r\n\t\tlet startsAt = matches.index\r\n\r\n\t\tnumber = number.replace(WHITESPACE_IN_THE_BEGINNING_PATTERN, '')\r\n\t\tstartsAt += matches[0].length - number.length\r\n\t\t// Fixes not parsing numbers with whitespace in the end.\r\n\t\t// Also fixes not parsing numbers with opening parentheses in the end.\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/252\r\n\t\tnumber = number.replace(PUNCTUATION_IN_THE_END_PATTERN, '')\r\n\r\n\t\tnumber = parsePreCandidate(number)\r\n\r\n\t\tconst result = this.parseCandidate(number, startsAt)\r\n\r\n\t\tif (result) {\r\n\t\t\treturn result\r\n\t\t}\r\n\r\n\t\t// Tail recursion.\r\n\t\t// Try the next one if this one is not a valid phone number.\r\n\t\treturn this.find()\r\n\t}\r\n\r\n\tparseCandidate(number, startsAt)\r\n\t{\r\n\t\tif (!isValidPreCandidate(number, startsAt, this.text)) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Don't parse phone numbers which are non-phone numbers\r\n\t\t// due to being part of something else (e.g. a UUID).\r\n\t\t// https://github.com/catamphetamine/libphonenumber-js/issues/213\r\n\t\t// Copy-pasted from Google's `PhoneNumberMatcher.js` (`.parseAndValidate()`).\r\n\t\tif (!isValidCandidate(number, startsAt, this.text, this.options.extended ? 'POSSIBLE' : 'VALID'))\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// // Prepend any opening brackets left behind by the\r\n\t\t// // `PHONE_NUMBER_START_PATTERN` regexp.\r\n\t\t// const text_before_number = text.slice(this.searching_from, startsAt)\r\n\t\t// const full_number_starts_at = text_before_number.search(BEFORE_NUMBER_DIGITS_PUNCTUATION)\r\n\t\t// if (full_number_starts_at >= 0)\r\n\t\t// {\r\n\t\t// \tnumber   = text_before_number.slice(full_number_starts_at) + number\r\n\t\t// \tstartsAt = full_number_starts_at\r\n\t\t// }\r\n\t\t//\r\n\t\t// this.searching_from = matches.lastIndex\r\n\r\n\t\tconst result = parse(number, this.options, this.metadata)\r\n\r\n\t\tif (!result.phone) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tresult.startsAt = startsAt\r\n\t\tresult.endsAt   = startsAt + number.length\r\n\r\n\t\treturn result\r\n\t}\r\n\r\n\thasNext()\r\n\t{\r\n\t\tif (this.state === 'NOT_READY')\r\n\t\t{\r\n\t\t\tthis.last_match = this.find()\r\n\r\n\t\t\tif (this.last_match)\r\n\t\t\t{\r\n\t\t\t\tthis.state = 'READY'\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.state = 'DONE'\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.state === 'READY'\r\n\t}\r\n\r\n\tnext()\r\n\t{\r\n\t\t// Check the state and find the next match as a side-effect if necessary.\r\n\t\tif (!this.hasNext())\r\n\t\t{\r\n\t\t\tthrow new Error('No next element')\r\n\t\t}\r\n\r\n\t\t// Don't retain that memory any longer than necessary.\r\n\t\tconst result = this.last_match\r\n\t\tthis.last_match = null\r\n\t\tthis.state = 'NOT_READY'\r\n\t\treturn result\r\n\t}\r\n}\r\n\r\nexport function sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parse('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\ttext = arg_1\r\n\t}\r\n\telse throw new TypeError('A text for parsing must be a string.')\r\n\r\n\t// If \"default country\" argument is being passed\r\n\t// then move it to `options`.\r\n\t// `findNumbers('88005553535', 'RU', [options], metadata)`.\r\n\tif (typeof arg_2 !== 'object')\r\n\t{\r\n\t\tif (arg_4)\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\r\n\t\t\tmetadata = arg_4\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2 }\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t}\r\n\t// No \"default country\" argument is being passed.\r\n\t// Only international phone numbers are passed.\r\n\t// `findNumbers('+78005553535', [options], metadata)`.\r\n\telse\r\n\t{\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\r\n\tif (!options)\r\n\t{\r\n\t\toptions = {}\r\n\t}\r\n\r\n\t// // Apply default options.\r\n\t// if (options)\r\n\t// {\r\n\t// \toptions = { ...default_options, ...options }\r\n\t// }\r\n\t// else\r\n\t// {\r\n\t// \toptions = default_options\r\n\t// }\r\n\r\n\treturn { text, options, metadata: new Metadata(metadata) }\r\n}"]}