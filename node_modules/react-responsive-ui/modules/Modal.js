'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ModalContext = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactModal = require('react-modal');

var _reactModal2 = _interopRequireDefault(_reactModal);

var _createReactContext = require('create-react-context');

var _createReactContext2 = _interopRequireDefault(_createReactContext);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _Form = require('./Form');

var _Form2 = _interopRequireDefault(_Form);

var _Button = require('./Button');

var _Button2 = _interopRequireDefault(_Button);

var _Close = require('./Close');

var _Close2 = _interopRequireDefault(_Close);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ModalContext = exports.ModalContext = (0, _createReactContext2.default)();

// Make sure to add `.rrui__fixed-full-width` CSS class
// to all full-width `position: fixed` elements.
// Such elements must not be `width: 100%`
// but rather `width: auto` or `left: 0; right: 0;`.
var Modal = (_temp = _class = function (_Component) {
	_inherits(Modal, _Component);

	function Modal(props) {
		_classCallCheck(this, Modal);

		var _this = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, props));

		_this.storeContentInstance = function (ref) {
			return _this.content = ref;
		};

		_this.registerForm = function () {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref) {
				var form = _ref.form;
				return { form: form + 1 };
			});
		};

		_this.unregisterForm = function () {
			if (_this.unmounted) {
				return;
			}

			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			_this.setState(function (_ref2) {
				var form = _ref2.form;
				return { form: form - 1 };
			});
		};

		_this.on_request_close = function (event) {
			var closeLabel = _this.props.closeLabel;
			var form = _this.state.form;

			// If the modal has an explicit "Cancel" button,
			// then allow closing it by hitting "Escape" key,
			// but don't close it on a click outside.
			// (because a user wouldn't want to loose form data due to a misclick)

			if (closeLabel && form && event && event.type !== 'keydown') {
				_this.indicate_cannot_close();
				// Focus on `<ReactModal/>` element.
				return _this.content.focus();
			}

			_this.closeIfNotBusy();
		};

		_this.closeIfNotBusy = function () {
			var _this$props = _this.props,
			    wait = _this$props.wait,
			    busy = _this$props.busy,
			    close = _this$props.close,
			    closeTimeout = _this$props.closeTimeout;

			// For weird messed development mode cases

			if (_this.unmounted) {
				return;
			}

			// Don't close the modal if it's busy
			if (wait || busy) {
				return _this.indicate_cannot_close();
			}

			// Abruptly end "couldn't close" animation to make room for closing animation
			_this.setState({ could_not_close_because_busy: false });

			// Close the modal
			if (close) {
				close();
			}
		};

		_this.on_after_open = function () {
			var afterOpen = _this.props.afterOpen;


			_this.adjust_scrollbar_after_open();

			if (afterOpen) {
				afterOpen();
			}
		};

		_this.on_after_close = function () {
			var _this$props2 = _this.props,
			    afterClose = _this$props2.afterClose,
			    reset = _this$props2.reset;


			if (reset) {
				reset();
			}

			if (afterClose) {
				afterClose();
			}

			_this.adjust_scrollbar_after_close();
		};

		_this.state = {
			// Using a counter instead of a boolean here
			// because a new form may be mounted before the old one is unmounted.
			// (React reconciliation algorythm implementation details)
			form: 0,

			context: {
				closeLabel: _this.props.closeLabel,
				closeIfNotBusy: _this.closeIfNotBusy,
				registerForm: _this.registerForm,
				unregisterForm: _this.unregisterForm
			}
		};
		return _this;
	}

	_createClass(Modal, [{
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			var _props = this.props,
			    unmount = _props.unmount,
			    isOpen = _props.isOpen;

			// If prevent `<Modal/>` contents
			// from being unmounted upon close.

			if (!unmount) {
				// If has been opened.
				if (!prevProps.isOpen && isOpen) {
					this.on_after_open();
				}
				// If has been closed.
				else if (prevProps.isOpen && !isOpen) {
						this.on_after_close();
						this.reset_content_scroll();
					}
			}
		}

		// A modal itself umounts only when the user leaves a page,
		// so in a "Single Page Application", for example,
		// if this was a regular popup and a user could still navigate
		// away via a hyperlink then this code becomes neccessary.

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var isOpen = this.props.isOpen;


			this.unmounted = true;

			// If the modal is still open
			// while a user navigates away
			// then "close" it properly
			// (restore the document scrollbars, etc).
			if (isOpen) {
				this.on_after_close();
			}

			clearTimeout(this.could_not_close_because_busy_animation_timeout);
			this.could_not_close_because_busy_animation_timeout = undefined;
		}
	}, {
		key: 'render',
		value: function render() {
			var _props2 = this.props,
			    wait = _props2.wait,
			    busy = _props2.busy,
			    fullscreen = _props2.fullscreen,
			    isOpen = _props2.isOpen,
			    closeTimeout = _props2.closeTimeout,
			    contentLabel = _props2.contentLabel,
			    title = _props2.title,
			    closeLabel = _props2.closeLabel,
			    closeButtonIcon = _props2.closeButtonIcon,
			    actions = _props2.actions,
			    unmount = _props2.unmount,
			    style = _props2.style,
			    className = _props2.className,
			    overlayClassName = _props2.overlayClassName,
			    children = _props2.children;
			var _state = this.state,
			    could_not_close_because_busy = _state.could_not_close_because_busy,
			    form = _state.form;


			return _react2.default.createElement(
				_reactModal2.default,
				{
					isOpen: unmount ? isOpen : true,
					onAfterOpen: unmount ? this.on_after_open : undefined,
					onRequestClose: this.on_request_close,
					closeTimeoutMS: closeTimeout,
					contentLabel: contentLabel,
					ariaHideApp: false,
					style: react_modal_style,
					overlayClassName: (0, _classnames2.default)('rrui__modal__overlay', {
						'rrui__modal__overlay--busy': wait || busy,
						'rrui__modal__overlay--fullscreen': fullscreen,
						'rrui__modal__overlay--hidden': !unmount && !isOpen
					}, overlayClassName),
					className: (0, _classnames2.default)('rrui__modal__container', {
						'rrui__modal__container--fullscreen': fullscreen
					}) },
				_react2.default.createElement('div', {
					className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--top', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close }),
				_react2.default.createElement(
					ModalContext.Provider,
					{ value: this.state.context },
					_react2.default.createElement(
						ModalContent,
						{
							ref: this.storeContentInstance,
							closeLabel: closeLabel,
							closeButtonIcon: closeButtonIcon,
							close: this.closeIfNotBusy,
							style: style,
							className: className,
							fullscreen: fullscreen,
							could_not_close_because_busy: could_not_close_because_busy,
							containsForm: form > 0,
							wait: wait || busy,
							reset: this.on_after_close },
						children
					)
				),
				_react2.default.createElement('div', {
					className: (0, _classnames2.default)('rrui__modal__vertical-margin', 'rrui__modal__vertical-margin--bottom', {
						// CSS selector performance optimization
						'rrui__modal__vertical-margin--fullscreen': fullscreen
					}),
					onClick: this.on_request_close })
			);
		}
	}, {
		key: 'indicate_cannot_close',


		// Play "cannot close" animation on the modal
		value: function indicate_cannot_close() {
			var _this2 = this;

			var could_not_close_because_busy_animation_duration = this.props.could_not_close_because_busy_animation_duration;
			var could_not_close_because_busy = this.state.could_not_close_because_busy;


			if (!could_not_close_because_busy) {
				this.could_not_close_because_busy_animation_timeout = setTimeout(function () {
					_this2.could_not_close_because_busy_animation_timeout = undefined;
					_this2.setState({ could_not_close_because_busy: false });
				},
				// Give it a bit of extra time to finish the CSS animation
				could_not_close_because_busy_animation_duration * 1.1);

				this.setState({ could_not_close_because_busy: true });
			}
		}
	}, {
		key: 'reset_content_scroll',


		// If the user scrolled on a previously shown react-modal,
		// then reset that previously scrolled position.
		value: function reset_content_scroll() {
			document.querySelector('.ReactModal__Overlay').scrollTop = 0;
		}

		// Hides the main (body) scrollbar upon showing a modal
		// and also adjusts the width of all "full-width" elements
		// so that they don't expand no that the scrollbar is absent.
		//
		// This doesn't account for window resizes
		// but since my body is always `overflow: visible` (a good practice)
		// there's no difference and it should work in any scenario.
		//

	}, {
		key: 'adjust_scrollbar_after_open',
		value: function adjust_scrollbar_after_open() {
			// A dummy `<div/>` to measure
			// the difference in width
			// needed for the "full-width" elements
			// after the main (body) scrollbar is deliberately hidden.
			var div = document.createElement('div');
			div.style.position = 'fixed';
			div.style.left = 0;
			div.style.right = 0;
			document.body.appendChild(div);

			// Calculate the width of the dummy `<div/>`
			// before the main (body) scrollbar is deliberately hidden.
			var width_before = div.clientWidth;

			// Hide the main (body) scrollbar
			// so that when a user scrolls in an open modal
			// this `scroll` event doesn't go through
			// and scroll the main page.
			document.body.style.overflow = 'hidden';

			// All "full-width" elements will need their
			// width to be adjusted by this amount
			// because of the now-hidden main (body) scrollbar

			// Calculate the width of the dummy `<div/>`
			// after the main (body) scrollbar is deliberately hidden.
			var width_adjustment = div.clientWidth - width_before;

			document.body.removeChild(div);

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements
			// so that they don't expand by the width of the (now absent) scrollbar
			//
			for (var _iterator = get_full_width_elements(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref3;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref3 = _iterator[_i++];
				} else {
					_i = _iterator.next();
					if (_i.done) break;
					_ref3 = _i.value;
				}

				var element = _ref3;

				element.style.marginRight = width_adjustment + 'px';
			}

			this.reset_content_scroll();
		}
	}, {
		key: 'adjust_scrollbar_after_close',


		// Restores original `document` scrollbar.
		value: function adjust_scrollbar_after_close() {
			var _props3 = this.props,
			    bodyOverflowX = _props3.bodyOverflowX,
			    bodyOverflowY = _props3.bodyOverflowY;

			// All "full-width" elements will need their
			// width to be restored back to the original value
			// now that the main (body) scrollbar is being restored.

			// "full-width" elements include `document.body`
			// and all `position: fixed` elements
			// which should be marked with this special CSS class.
			//
			// Make sure to add `.rrui__fixed-full-width` CSS class
			// to all full-width `position: fixed` elements.
			// Such elements must not be `width: 100%`
			// but rather `width: auto` or `left: 0; right: 0;`.
			//
			// Adjusts the width of all "full-width" elements back to their original value
			// now that the main (body) scrollbar is being restored.
			//

			for (var _iterator2 = get_full_width_elements(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
				var _ref4;

				if (_isArray2) {
					if (_i2 >= _iterator2.length) break;
					_ref4 = _iterator2[_i2++];
				} else {
					_i2 = _iterator2.next();
					if (_i2.done) break;
					_ref4 = _i2.value;
				}

				var element = _ref4;

				element.style.marginRight = 0;
			}

			// Restore the main (body) scrollbar.
			document.body.style.overflowX = bodyOverflowX;
			document.body.style.overflowY = bodyOverflowY;
		}

		// Restores original `document` scrollbar
		// and resets the modal content (e.g. a form)

	}], [{
		key: 'getDerivedStateFromProps',
		value: function getDerivedStateFromProps(props, state) {
			if (props.closeLabel !== state.context.closeLabel) {
				return _extends({}, state, {
					context: _extends({}, state.context, {
						closeLabel: props.closeLabel
					})
				});
			}

			return null;
		}
	}]);

	return Modal;
}(_react.Component), _class.propTypes = {
	// If `true` then the modal is shown
	isOpen: _propTypes2.default.bool.isRequired,

	// Closes the modal (must set the `isOpen` flag to `false`)
	close: _propTypes2.default.func.isRequired,

	// A time required for CSS hiding animation to complete
	// (150 milliseconds by default)
	closeTimeout: _propTypes2.default.number.isRequired,

	// Is called after the modal is shown
	afterOpen: _propTypes2.default.func,

	// Is called after the modal is closed
	afterClose: _propTypes2.default.func,

	// Enters fullscreen mode
	fullscreen: _propTypes2.default.bool,

	// Modal content
	children: _propTypes2.default.node,

	// If `wait` is `true` then the modal
	// won't close on click-out or Escape
	// and will show spinner on the overlay.
	wait: _propTypes2.default.bool,

	// (deprecated)
	// (use `wait` instead)
	// If `busy` is `true` then the modal
	// won't close on click-out or Escape
	// and will show spinner on the overlay.
	busy: _propTypes2.default.bool,

	// Resets the modal on close
	// (e.g. could reset edited form fields)
	reset: _propTypes2.default.func,

	// "Cancel" button label.
	// If set, the modal will have a "Cancel" button.
	// (only if `<Form.Actions/>` is found in content)
	closeLabel: _propTypes2.default.string,

	// The default `overflow-x` of the <body/>.
	// Is `auto` by default.
	bodyOverflowX: _propTypes2.default.string.isRequired,

	// The default `overflow-x` of the <body/>.
	// Is `scroll` by default
	// (which is better than `auto`
	//  because the document width won't be jumpy
	//  while navigating the website —
	//  it will be consistent across all pages)
	bodyOverflowY: _propTypes2.default.string.isRequired,

	// `aria-label` for the modal.
	// (is "Popup" by default)
	contentLabel: _propTypes2.default.string.isRequired,

	// An optional close button icon (like a cross).
	// Set to `true` to show the default "cross" icon.
	closeButtonIcon: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.oneOf([true])]),

	// If set to `false` will prevent modal contents
	// from being unmounted when the modal is closed.
	unmount: _propTypes2.default.bool.isRequired,

	// Internal property
	could_not_close_because_busy_animation_duration: _propTypes2.default.number.isRequired,

	// CSS class for overlay (e.g. for fullscreen modal background color)
	overlayClassName: _propTypes2.default.string,

	// CSS class
	className: _propTypes2.default.string,

	// CSS style object
	style: _propTypes2.default.object
}, _class.defaultProps = {
	isOpen: false,

	bodyOverflowX: 'auto',
	// Prevents document width from jumping due to the
	// vertical scrollbar appearance/disappearance
	bodyOverflowY: 'scroll',

	// when changing this also change
	// your .ReactModal__Overlay and .ReactModal__Content
	// css transition times accordingly
	closeTimeout: 150, // ms

	contentLabel: 'Popup',

	// Modal contents are unmounted when the modal is closed by default
	unmount: true,

	// When changing this also change
	// `.rrui__modal--could-not-close-because-busy`
	// css transition time accordingly
	could_not_close_because_busy_animation_duration: 600 // ms
}, _temp);

var ModalContent = function (_Component2) {
	_inherits(ModalContent, _Component2);

	function ModalContent() {
		var _ref5;

		var _temp2, _this3, _ret;

		_classCallCheck(this, ModalContent);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp2 = (_this3 = _possibleConstructorReturn(this, (_ref5 = ModalContent.__proto__ || Object.getPrototypeOf(ModalContent)).call.apply(_ref5, [this].concat(args))), _this3), _this3.storeNode = function (ref) {
			return _this3.node = ref;
		}, _temp2), _possibleConstructorReturn(_this3, _ret);
	}

	_createClass(ModalContent, [{
		key: 'focus',
		value: function focus() {
			this.node.focus();
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var reset = this.props.reset;


			if (reset) {
				reset();
			}
		}
	}, {
		key: 'transformChildren',
		value: function transformChildren() {
			var _this4 = this;

			var _props4 = this.props,
			    closeLabel = _props4.closeLabel,
			    closeButtonIcon = _props4.closeButtonIcon,
			    close = _props4.close,
			    containsForm = _props4.containsForm,
			    children = _props4.children;


			var closeButtonAdded = false;
			return _react2.default.Children.map(children, function (element) {
				if (closeButtonIcon && !closeButtonAdded) {
					if (element.type === ModalTitleType || element.type === ModalContentType) {
						closeButtonAdded = true;
						return _react2.default.cloneElement(element, {
							closeButton: _this4.render_close_button()
						});
					}
				}

				if (!closeButtonIcon && closeLabel && !containsForm && element.type === Modal.Actions) {
					return _react2.default.cloneElement(element, {
						closeButton: _react2.default.createElement(
							_Button2.default,
							{
								className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--bottom'),
								action: close },
							closeLabel
						)
					});
				}

				return element;
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _props5 = this.props,
			    fullscreen = _props5.fullscreen,
			    className = _props5.className,
			    style = _props5.style,
			    could_not_close_because_busy = _props5.could_not_close_because_busy;


			return _react2.default.createElement(
				'div',
				{
					ref: this.storeNode,
					className: (0, _classnames2.default)('rrui__modal__contents', {
						// CSS selector performance optimization
						'rrui__modal__contents--fullscreen': fullscreen,

						// Strictly speaking it's not `.rrui__modal` but this CSS class name will do
						'rrui__modal--could-not-close-because-busy': could_not_close_because_busy
					}, className),
					style: style },
				this.transformChildren()
			);
		}
	}, {
		key: 'render_close_button',
		value: function render_close_button() {
			var _props6 = this.props,
			    closeLabel = _props6.closeLabel,
			    closeButtonIcon = _props6.closeButtonIcon,
			    close = _props6.close,
			    wait = _props6.wait;


			var CloseButtonIcon = closeButtonIcon === true ? _Close.CloseIcon : closeButtonIcon;

			if (!CloseButtonIcon) {
				return null;
			}

			return _react2.default.createElement(
				_Close2.default,
				{
					onClick: close,
					closeLabel: closeLabel,
					className: (0, _classnames2.default)('rrui__modal__close', 'rrui__modal__close--top', {
						'rrui__modal__close--busy': wait
					}) },
				_react2.default.createElement(CloseButtonIcon, null)
			);
		}
	}]);

	return ModalContent;
}(_react.Component);

var react_modal_style = {
	overlay: {
		position: 'fixed',
		left: 0,
		top: 0,
		right: 0,
		bottom: 0,
		// Will show a scrollbar in case of modal content overflowing viewport height
		overflow: 'auto'
	}

	// "full-width" elements include `document.body`
	// and all `position: fixed` elements
	// which should be marked with this special CSS class.
	//
	// Make sure to add `.rrui__fixed-full-width` CSS class
	// to all full-width `position: fixed` elements.
	// Such elements must not be `width: 100%`
	// but rather `width: auto` or `left: 0; right: 0;`.
	//
};function get_full_width_elements() {
	// `Array.from` requires ES6 polyfill.
	// const full_width_elements = Array.from(document.querySelectorAll('.rrui__fixed-full-width'))
	var full_width_elements = [].slice.call(document.querySelectorAll('.rrui__fixed-full-width'));
	full_width_elements.push(document.body);
	return full_width_elements;
}

var Title = function Title(_ref6) {
	var closeButton = _ref6.closeButton,
	    className = _ref6.className,
	    children = _ref6.children,
	    rest = _objectWithoutProperties(_ref6, ['closeButton', 'className', 'children']);

	return _react2.default.createElement(
		'h2',
		_extends({
			className: (0, _classnames2.default)('rrui__modal__title', className, {
				'rrui__modal__title--close-button': closeButton
			})
		}, rest),
		closeButton && _react2.default.createElement(
			'span',
			{ className: 'rrui__modal__title-itself' },
			children
		),
		!closeButton && children,
		closeButton
	);
};

var Content = function Content(_ref7) {
	var closeButton = _ref7.closeButton,
	    className = _ref7.className,
	    children = _ref7.children,
	    rest = _objectWithoutProperties(_ref7, ['closeButton', 'className', 'children']);

	return _react2.default.createElement(
		'div',
		_extends({
			className: (0, _classnames2.default)('rrui__modal__content', className, {
				'rrui__modal__content--close-button': closeButton
			})
		}, rest),
		closeButton && _react2.default.createElement(
			'div',
			{ className: 'rrui__modal__content-itself' },
			children
		),
		!closeButton && children,
		closeButton
	);
};

var Actions = function Actions(_ref8) {
	var closeButton = _ref8.closeButton,
	    children = _ref8.children;
	return _react2.default.createElement(
		'div',
		{ className: 'rrui__modal__actions' },
		closeButton,
		children
	);
};

// Workaround for `react-hot-loader`.
// https://github.com/gaearon/react-hot-loader#checking-element-types
var ModalTitleType = _react2.default.createElement(Title, null).type;
var ModalContentType = _react2.default.createElement(Content, null).type;

Modal = (0, _reactLifecyclesCompat.polyfill)(Modal);

Modal.Title = Title;
Modal.Content = Content;
Modal.Actions = Actions;

exports.default = Modal;
//# sourceMappingURL=Modal.js.map