'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _class2, _temp2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _ExpandableList = require('./ExpandableList');

var _ExpandableList2 = _interopRequireDefault(_ExpandableList);

var _List = require('./List');

var _List2 = _interopRequireDefault(_List);

var _TextInputLabel = require('./TextInputLabel');

var _TextInputLabel2 = _interopRequireDefault(_TextInputLabel);

var _TextInputInput = require('./TextInputInput');

var _TextInputInput2 = _interopRequireDefault(_TextInputInput);

var _Ellipsis = require('./Ellipsis');

var _Ellipsis2 = _interopRequireDefault(_Ellipsis);

var _reduxForm = require('./utility/redux-form');

var _dom = require('./utility/dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

var empty_value_option_value = '';

var Autocomplete = (0, _reactLifecyclesCompat.polyfill)(_class = (_temp2 = _class2 = function (_PureComponent) {
	_inherits(Autocomplete, _PureComponent);

	function Autocomplete() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Autocomplete);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			// The sequential counter for `async getOptions()`:
			// the `options` with the highest counter are shown
			// to prevent "race condition" inconsistency.
			// Older options can only be overwritten with newer ones.
			optionsCounter: 0,
			matchesCounter: 0,

			inputValue: '',
			options: [],

			// `prevProps` for `getDerivedStateFromProps()`.
			props: {}

			// Latest `async getOptions()` invocation timestamp (for throttling).
		}, _this.latestFetchOptionsCallTimestamp = 0, _this.counter = new Counter(), _this.onPreloadStateChange = function (isPreloading) {
			return _this.setState({ isFetchingOptions: isPreloading });
		}, _this.focus = function () {
			return _this.input.focus();
		}, _this.onCollapse = function (_ref2) {
			var collapsedDueToItemBeingSelected = _ref2.collapsedDueToItemBeingSelected,
			    focusOut = _ref2.focusOut;
			var _this$state = _this.state,
			    options = _this$state.options,
			    selectedOption = _this$state.selectedOption;


			_this.setState({
				isExpanded: false,
				matches: undefined
			});

			if (!collapsedDueToItemBeingSelected && !_this.collapsedDueToEmptyValueOnEnter) {
				_this.setState({
					inputValue: selectedOption ? selectedOption.label : ''
				});
			}

			if (!focusOut) {
				_this.dontExpandOnFocus = true;
				_this.focus();
				_this.dontExpandOnFocus = false;
			}
		}, _this.onExpand = function () {
			var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			_this.setState({ isExpanded: true });
		}, _this.expand = function () {
			// Reset the "matches" state before expanding.
			_this.setState({ matches: true }, _this._expand);
		}, _this._expand = function (parameters) {
			return _this.list.expand(parameters);
		}, _this.collapse = function () {
			return _this.list.collapse();
		}, _this.toggle = function () {
			return _this.list.toggle();
		}, _this.storeListRef = function (ref) {
			return _this.list = ref;
		}, _this.storeInput = function (node) {
			return _this.input = node;
		}, _this.storeInputComponentNode = function (node) {
			return _this.inputComponentNode = node;
		}, _this.getInputNode = function () {
			return _this.input;
		}, _this.expandOnFocus = function () {
			if (_this.dontExpandOnFocus) {
				return;
			}

			var isExpanded = _this.state.isExpanded;


			if (!isExpanded) {
				_this.setState({ matches: true }, _this.expand);
			}
		}, _this.onInputValueChange = function (value) {
			var isExpanded = _this.state.isExpanded;


			if (!value && isExpanded) {
				_this.list.focusItem(undefined);
			}

			_this.setState({
				inputValue: value
			}, function () {
				_this._expand({ refresh: true });
			});
		}, _this.onKeyDown = function (event) {
			var _this$props = _this.props,
			    disabled = _this$props.disabled,
			    value = _this$props.value,
			    required = _this$props.required;
			var _this$state2 = _this.state,
			    isExpanded = _this$state2.isExpanded,
			    inputValue = _this$state2.inputValue;


			if (disabled) {
				return;
			}

			if (event.defaultPrevented) {
				return;
			}

			if (!isExpanded) {
				if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {
					return;
				}
			}

			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			switch (event.keyCode) {
				// "Up" arrow.
				// Select the previous item (if present).
				case 38:
					if (isExpanded) {
						if (_this.list.getFocusedItemIndex() === undefined) {
							// Don't select any list item.
						} else if (_this.list.getFocusedItemIndex() === 0) {
							_this.list.focusItem(undefined);
							event.preventDefault();
						} else {
							_this.list.onKeyDown(event);
						}
					}
					return;

				// "Down" arrow.
				// Select the next item (if present).
				case 40:
					if (isExpanded) {
						// Navigate the list (if it was already expanded).
						_this.list.onKeyDown(event);
					} else {
						// Expand the list if it's collapsed.
						event.preventDefault();
						_this.expand();
					}
					return;

				// "Escape".
				// Collapse.
				case 27:
					event.preventDefault();
					_this.collapse();
					return;

				// "Enter".
				case 13:
					if (!inputValue) {
						if (isExpanded && _this.list.getFocusedItemIndex() === undefined) {
							event.preventDefault();
							_this.setValue(undefined);

							_this.collapsedDueToEmptyValueOnEnter = true;
							_this.collapse();
							_this.collapsedDueToEmptyValueOnEnter = undefined;

							return;
						}

						if (!isExpanded) {
							if (isEmptyValue(value)) {
								// Submit containing `<form/>`.
								// If the value is required then expand instead.
								if (required) {
									event.preventDefault();
									_this.expand();
								}
								return;
							}

							event.preventDefault();
							_this.setValue(undefined);
							return;
						}
					}

					// Select the currently focused item (if expanded).
					if (isExpanded) {
						_this.list.onKeyDown(event);
						return;
					}

					return;
			}
		}, _this.fetchDefaultOptions = function () {
			var _this$props2 = _this.props,
			    getOptions = _this$props2.getOptions,
			    filterOptions = _this$props2.filterOptions;


			return Promise.resolve().then(function () {
				return getOptions ? getOptions('') : filterOptions(_this.props.options, '');
			}).then(function () {
				return new Promise(function (resolve) {
					return _this.setState({ options: options }, resolve);
				});
			});
		}, _this.refreshOptions = function () {
			var _this$props3 = _this.props,
			    getOptions = _this$props3.getOptions,
			    filterOptions = _this$props3.filterOptions;
			var inputValue = _this.state.inputValue;


			return new Promise(function (resolve) {
				// If throttled then schedule a future invocation.
				if (getOptions) {
					if (_this.throttleFetchOptionsCall(resolve)) {
						return;
					}

					_this.latestFetchOptionsCallTimestamp = Date.now();

					var counter = _this.counter.getNextCounter();

					return _this.setState({
						isFetchingOptions: true,
						fetchingOptionsCounter: counter
					}, function () {
						getOptions(inputValue).then(function (options) {
							_this.handleNewOptions(options, counter, resolve);
						});
					});
				}

				var newOptions = filterOptions(_this.props.options, inputValue);
				_this.handleNewOptions(newOptions, null, resolve);
			});
		}, _this.handleNewOptions = function (options, counter, resolve) {
			Promise.resolve(options).then(function (options) {
				// Autocomplete should always display some options.
				if (options.length === 0 && _this.state.options.length === 0) {
					return _this.fetchDefaultOptions().then(function () {
						return options;
					});
				}
				return options;
			}).then(function (options) {
				_this.receiveNewOptions(options, counter, resolve);
			}).catch(function (error) {
				console.error(error);
				_this.receiveNewOptions([], counter, resolve);
			});
		}, _this.setValue = function (newValue) {
			var _this$props4 = _this.props,
			    value = _this$props4.value,
			    onChange = _this$props4.onChange;
			var options = _this.state.options;


			var selectedOption = options.filter(function (_) {
				return _.value === newValue;
			})[0];

			_this.setState({
				selectedOption: selectedOption,
				inputValue: selectedOption ? selectedOption.label : ''
			});

			// Call `onChange` only if the `value` did change.
			if (newValue !== value) {
				onChange(newValue);
			}
		}, _this.onBlur = function (event) {
			return _this.list && _this.list.onBlur(event);
		}, _this.onClick = function (event) {
			var disabled = _this.props.disabled;


			if (!disabled) {
				_this.expandOnFocus();
			}
		}, _this.onFocusOut = function (event) {
			var _this$props5 = _this.props,
			    onBlur = _this$props5.onBlur,
			    value = _this$props5.value;
			var inputValue = _this.state.inputValue;


			_this.collapse();

			if (!inputValue) {
				value = undefined;
				_this.setValue(value);
			}

			if (onBlur) {
				(0, _reduxForm.onBlurForReduxForm)(onBlur, event, value);
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	// Older options can only be overwritten with newer ones.
	// (in case of `async getOptions()`).


	_createClass(Autocomplete, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var _props = this.props,
			    value = _props.value,
			    getOptions = _props.getOptions,
			    getOption = _props.getOption;


			if (!isEmptyValue(value) && !getOption && getOptions) {
				throw new Error("An initial `value` was passed to `<Autocomplete/>` which has `getOptions` but doesn't have `getOption` to get the label for that initial `value`.");
			}

			if (!isEmptyValue(value) && getOption) {
				this.setState({
					isFetchingInitiallySelectedOption: true
				});

				getOption(value).then(function (option) {
					_this2.setState({
						selectedOption: option,
						inputValue: option ? option.label : '',
						isFetchingInitiallySelectedOption: false
					});
				}, function (error) {
					console.error(error);
					_this2.setState({
						isFetchingInitiallySelectedOption: false
					});
				});
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.nextFetchOptionsCallTimeout);
		}
	}, {
		key: 'render',
		value: function render() {
			var _props2 = this.props,
			    id = _props2.id,
			    icon = _props2.icon,
			    compact = _props2.compact,
			    scroll = _props2.scroll,
			    scrollMaxItems = _props2.scrollMaxItems,
			    scrollIntoView = _props2.scrollIntoView,
			    alignment = _props2.alignment,
			    saveOnIcons = _props2.saveOnIcons,
			    required = _props2.required,
			    label = _props2.label,
			    value = _props2.value,
			    onChange = _props2.onChange,
			    indicateInvalid = _props2.indicateInvalid,
			    error = _props2.error,
			    closeButtonIcon = _props2.closeButtonIcon,
			    closeLabel = _props2.closeLabel,
			    style = _props2.style,
			    className = _props2.className;
			var _state = this.state,
			    options = _state.options,
			    isFetchingOptions = _state.isFetchingOptions,
			    isFetchingInitiallySelectedOption = _state.isFetchingInitiallySelectedOption,
			    isExpanded = _state.isExpanded,
			    inputValue = _state.inputValue;


			var containerStyle = { textAlign: alignment };

			return _react2.default.createElement(
				'div',
				{
					style: style ? _extends({}, containerStyle, style) : containerStyle,
					className: (0, _classnames2.default)('rrui__autocomplete', {
						'rrui__autocomplete--expanded': isExpanded,
						'rrui__autocomplete--compact': compact || icon
					}, className) },
				_react2.default.createElement(
					'div',
					{
						ref: this.storeInputComponentNode,
						className: 'rrui__input' },
					(isFetchingOptions || isFetchingInitiallySelectedOption) && _react2.default.createElement(_Ellipsis2.default, null),
					this.renderTextInput(),
					label && _react2.default.createElement(
						_TextInputLabel2.default,
						{
							id: id,
							value: value,
							required: required,
							invalid: indicateInvalid && error },
						label
					),
					_react2.default.createElement(
						_ExpandableList2.default,
						{
							ref: this.storeListRef,
							items: options,
							focusFirstItemWhenItemsChange: inputValue !== '',
							alignment: alignment,
							scrollIntoView: scrollIntoView,
							preload: this.refreshOptions,
							onPreloadStateChange: this.onPreloadStateChange,
							scrollMaxItems: scroll === false ? 0 : scrollMaxItems,
							shouldFocus: false,
							value: options.length === 0 ? undefined : inputValue.trim() === '' ? undefined : value,
							onChange: this.setValue,
							onCollapse: this.onCollapse,
							onExpand: this.onExpand,
							focusOnExpand: false,
							highlightSelectedItem: false,
							getTogglerNode: this.getInputNode,
							onFocusOut: this.onFocusOut,
							closeButtonIcon: closeButtonIcon,
							closeLabel: closeLabel,
							className: (0, _classnames2.default)('rrui__shadow', 'rrui__options-list', {
								'rrui__options-list--left-aligned': alignment === 'left',
								'rrui__options-list--right-aligned': alignment === 'right'
							}) },
						this.getOptionsForRendering().map(function (option, i) {
							return _react2.default.createElement(
								_List2.default.Item,
								{
									key: i,
									value: option.value,
									icon: saveOnIcons ? undefined : option.icon },
								option.content ? option.content(option) : option.label
							);
						})
					)
				),
				indicateInvalid && error && _react2.default.createElement(
					'div',
					{ className: 'rrui__input-error' },
					error
				)
			);
		}
	}, {
		key: 'renderTextInput',
		value: function renderTextInput() {
			var _props3 = this.props,
			    value = _props3.value,
			    placeholder = _props3.placeholder,
			    disabled = _props3.disabled,
			    required = _props3.required,
			    indicateInvalid = _props3.indicateInvalid,
			    error = _props3.error,
			    tabIndex = _props3.tabIndex,
			    inputClassName = _props3.inputClassName;
			var _state2 = this.state,
			    isExpanded = _state2.isExpanded,
			    inputValue = _state2.inputValue,
			    matches = _state2.matches,
			    isFetchingInitiallySelectedOption = _state2.isFetchingInitiallySelectedOption;

			// To expand on click/focus:
			// onFocus={ this.expandOnFocus }
			// onClick={ this.onClick }

			return _react2.default.createElement(_TextInputInput2.default, {
				inputRef: this.storeInput,
				value: inputValue,
				placeholder: placeholder,
				onChange: this.onInputValueChange,
				onKeyDown: this.onKeyDown,
				onBlur: this.onBlur,
				tabIndex: tabIndex,
				disabled: isFetchingInitiallySelectedOption || disabled,
				indicateInvalid: indicateInvalid || matches === false,
				error: error || (matches === false ? 'no-match' : undefined),
				className: (0, _classnames2.default)('rrui__autocomplete__input', inputClassName) });
		}
	}, {
		key: 'getOptionsForRendering',
		value: function getOptionsForRendering() {
			var maxOptions = this.props.maxOptions;
			var options = this.state.options;


			if (maxOptions > 0 && options.length > maxOptions) {
				return options.slice(0, maxOptions);
			}

			return options;
		}
	}, {
		key: 'throttleFetchOptionsCall',
		value: function throttleFetchOptionsCall(resolve) {
			var _this3 = this;

			var _props4 = this.props,
			    throttle = _props4.throttle,
			    minCharactersToStartThrottling = _props4.minCharactersToStartThrottling;
			var inputValue = this.state.inputValue;


			var wait = throttle - (Date.now() - this.latestFetchOptionsCallTimestamp);

			if (inputValue.length >= minCharactersToStartThrottling && wait > 0) {
				if (!this.nextFetchOptionsCallTimeout) {
					this.nextFetchOptionsCallTimeout = setTimeout(function () {
						_this3.nextFetchOptionsCallTimeout = undefined;
						_this3.latestFetchOptionsCall();
					}, wait);
				}

				this.latestFetchOptionsCall = function () {
					return _this3.refreshOptions().then(resolve);
				};
				return true;
			}
		}
	}, {
		key: 'receiveNewOptions',
		value: function receiveNewOptions(options, counter, callback) {
			var getOptions = this.props.getOptions;
			var _state3 = this.state,
			    matchesCounter = _state3.matchesCounter,
			    optionsCounter = _state3.optionsCounter,
			    fetchingOptionsCounter = _state3.fetchingOptionsCounter;


			var newState = {};

			if (getOptions) {
				// Can only override "older" matching state.
				if (isCounterAfter(counter, matchesCounter)) {
					newState.matches = options.length > 0;
					newState.matchesCounter = counter;
				}

				// Update options.
				// Can only override "older" options.
				// (not "newer" ones)
				if (isCounterAfter(counter, optionsCounter)) {
					// Autocomplete should always display some options.
					if (options.length > 0) {
						newState.options = options;
						newState.optionsCounter = counter;
					}
				}

				if (counter === fetchingOptionsCounter) {
					newState.isFetchingOptions = false;
					newState.fetchingOptionsCounter = undefined;
				}
			} else {
				newState.matches = options.length > 0;

				// Autocomplete should always display some options.
				if (options.length > 0) {
					newState.options = options;
				}
			}

			this.setState(newState, callback);
		}
	}], [{
		key: 'getDerivedStateFromProps',


		// Handles changing `value` externally for an `<Autocomplete/>`.
		value: function getDerivedStateFromProps(_ref3, state) {
			var value = _ref3.value,
			    options = _ref3.options;

			var newState = {
				// `prevProps`.
				props: {
					value: value
				}

				// Changing `value` externally for an `<Autocomplete/>`
				// with `async getOptions()` is not supported.
			};if (Array.isArray(options)) {
				// `<Autocomplete/>`'s selected option label
				// is stored in a special `selectedOption.label` variable in `state`.
				if (value !== state.props.value) {
					newState.selectedOption = options.filter(function (_) {
						return _.value === value;
					})[0];
					newState.inputValue = newState.selectedOption ? newState.selectedOption.label : '';
				}
			}

			return newState;
		}
	}]);

	return Autocomplete;
}(PureComponent), _class2.propTypes = {
	// A list of selectable options
	options: _propTypes2.default.arrayOf(_propTypes2.default.shape({
		// Option value (may be `undefined`)
		value: _propTypes2.default.any,
		// Option label (may be `undefined`)
		label: _propTypes2.default.string,
		// Option icon
		icon: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func]),
		// Render custom content (a React component).
		// Receives `{ value, label }` properties.
		content: _propTypes2.default.func
	})).isRequired,

	// An alternative way of getting `options`.
	// If it's an `autocomplete` then this function
	// receives the `query : string` argument.
	// Is only for `autocomplete` mode.
	// Must return a `Promise`.
	getOptions: _propTypes2.default.func,

	// Can be supplied when supplying `options` prop.
	// By default filters by substring inclusion (case-insensitive).
	filterOptions: _propTypes2.default.func.isRequired,

	// The maximum number of options to be rendered
	// in the options list when it's expanded.
	// `0` means "unlimited".
	maxOptions: _propTypes2.default.number,

	// Throttle `async getOptions()` invocations.
	throttle: _propTypes2.default.number.isRequired,

	// Throttle `async getOptions()` invocations.
	minCharactersToStartThrottling: _propTypes2.default.number.isRequired,

	// HTML form input `name` attribute
	name: _propTypes2.default.string,

	// Label which is placed above the select
	label: _propTypes2.default.string,

	// Placeholder (like "Choose")
	placeholder: _propTypes2.default.string,

	// Show icon only for selected item,
	// and only if `icon` is `true`.
	saveOnIcons: _propTypes2.default.bool,

	// Disables this control
	disabled: _propTypes2.default.bool,

	// Set to `true` to mark the field as required
	required: _propTypes2.default.bool.isRequired,

	// Selected option value
	value: _propTypes2.default.any,

	// Is called when an option is selected
	onChange: _propTypes2.default.func,

	// Is called when the select is blurred.
	// This `onBlur` interceptor is a workaround for `redux-form`,
	// so that it gets the parsed `value` in its `onBlur` handler,
	// not the formatted text.
	onBlur: _propTypes2.default.func,

	// If `scroll` is `false`, then options list
	// is not limited in height.
	// Is `true` by default (scrollable).
	scroll: _propTypes2.default.bool.isRequired,

	// Component CSS class
	className: _propTypes2.default.string,

	// Autocomplete `<input/>` CSS class
	inputClassName: _propTypes2.default.string,

	// CSS style object
	style: _propTypes2.default.object,

	// If this flag is set to `true`,
	// and `icon` is specified for a selected option,
	// then the selected option will be displayed
	// as icon only, without the label.
	icon: _propTypes2.default.bool,

	// If this flag is set to `true`,
	// then it makes `<Autocomplete/>` not stretch itself
	// to 100% width by making it `inline-block`.
	// Is set to `true` when `icon` is `true`
	// because it makes sense.
	compact: _propTypes2.default.bool,

	// HTML `tabindex` attribute
	tabIndex: _propTypes2.default.number,

	// If set to `true`, autocomple will show all
	// matching options instead of just `maxItems`.
	showAllMatchingOptions: _propTypes2.default.bool,

	// `<Autocomplete/>` loads `async getOptions()` after it has been mounted.
	// Until then `<Autocomplete/>` doesn't display any selected option.
	// One may supply an already pre-loaded currently selected option
	// to display the currently selected option sooner (e.g. Server-Side Rendering).
	selectedOption: _propTypes2.default.object
}, _class2.defaultProps = {
	// Set to `true` to mark the field as required
	required: false,

	// Show `error` (if passed).
	indicateInvalid: true,

	// Set to `true` to display the loading indicator
	loading: false,

	// Will show scrollbar on overflow.
	scroll: true,

	alignment: 'left',

	// `async getOptions()` throttle period.
	throttle: 200,

	// `async getOptions()` throttle threshold (in characters).
	minCharactersToStartThrottling: 4,

	// Filters options by substring inclusion (case-insensitive).
	filterOptions: filterOptions,

	// The maximum number of options to be rendered
	// in the options list when it's expanded.
	// The rationale is that otherwise the UI could
	// stagger when initially expanding a huge list.
	// `0` means "unlimited".
	maxOptions: 500
}, _temp2)) || _class;

// There can be an `undefined` value,
// so just `{ value }` won't do here.


exports.default = Autocomplete;
function getOptionKey(value) {
	return isEmptyValue(value) ? '@@rrui/empty' : value;
}

function isEmptyValue(value) {
	return value === null || value === undefined;
}

// Filters options by substring inclusion (case-insensitive).
function filterOptions(options, value) {
	// If the input value is `undefined` or empty.
	if (!value) {
		return options;
	}

	value = value.toLowerCase();

	return options.filter(function (_ref4) {
		var label = _ref4.label;
		return label.toLowerCase().indexOf(value) >= 0;
	});
}

var Counter = function () {
	function Counter() {
		_classCallCheck(this, Counter);

		this.counter = 0;
	}

	_createClass(Counter, [{
		key: 'getNextCounter',
		value: function getNextCounter() {
			if (this.counter < MAX_SAFE_INTEGER) {
				this.counter++;
			} else {
				this.counter = 1;
			}
			return this.counter;
		}
	}]);

	return Counter;
}();

// `MAX_SAFE_INTEGER` is not supported by older browsers


var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

// Can only override "older" options.
// (not "newer" ones)
function isCounterAfter(counter, currentStateCounter) {
	var diff = counter - currentStateCounter;

	// If the new options are "newer" than the current ones,
	// then they can override them.
	// (also accounts for counter overflow)
	return diff > 0 || diff < 0 && Math.abs(diff) > MAX_SAFE_INTEGER / 2;
}
//# sourceMappingURL=Autocomplete.js.map