{"version":3,"sources":["../source/PhoneNumberMatcher.js"],"names":["INNER_MATCHES","leadLimit","punctuationLimit","digitBlockLimit","blockLimit","punctuation","digitSequence","PATTERN","UNWANTED_END_CHAR_PATTERN","RegExp","NON_DIGITS_PATTERN","MAX_SAFE_INTEGER","Number","Math","pow","PhoneNumberMatcher","text","options","metadata","state","searchIndex","leniency","extended","maxTries","TypeError","matches","exec","candidate","offset","index","match","parseAndVerify","extractInnerMatch","v2","phoneNumber","country","phone","ext","startsAt","endsAt","number","innerMatchPattern","isFirstMatch","possibleInnerMatch","group","slice","defaultCountry","possible","result","length","lastMatch","find","hasNext","Error"],"mappings":";;;;;;;;qjBAAA;;;;;;AAMA;;;;AAEA;;AASA;;AAOA;;AAUA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;AACA;;;;AACA;;;;;;;;AAEA;;;;;;;;;;AAUA,IAAMA,gBACN;AACC;AACA,WAFD;;AAIC;AACA;AACA,YAND;;AAQC;AACA;AATD;;AAYC;AACA;AACA;AAdD;;AAiBC;AAjBD;;AAoBC;AApBD,gCADA;;AAyBA;AACA,IAAMC,YAAY,iBAAM,CAAN,EAAS,CAAT,CAAlB;;AAEA;AACA,IAAMC,mBAAmB,iBAAM,CAAN,EAAS,CAAT,CAAzB;;AAEA;;;AAGA,IAAMC,kBAAkB,4DAAxB;;AAEA;AACA;AACA,IAAMC,aAAa,iBAAM,CAAN,EAASD,eAAT,CAAnB;;AAEA;AACA,IAAME,cAAc,wCAA2BH,gBAA/C;;AAEA;AACA,IAAMI,gBAAgB,WAAM,iBAAM,CAAN,EAASH,eAAT,CAA5B;;AAEA;;;;;;;;;;;;;;;;AAgBA,IAAMI,UAAU,uCAAqBF,WAArB,GAAmC,GAAnC,GAAyCJ,SAAzC,GACbK,aADa,GACG,KADH,GACWD,WADX,GACyBC,aADzB,GACyC,GADzC,GAC+CF,UAD/C,GAEb,KAFa,GAEL,sCAAyB,UAAzB,CAFK,GAEkC,IAFlD;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMI,4BAA4B,IAAIC,MAAJ,qCAAlC;;AAEA,IAAMC,qBAAqB,OAA3B;;AAEA,IAAMC,mBAAmBC,OAAOD,gBAAP,IAA2BE,KAAKC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAAtE;;AAEA;;;;;;;;;;;IAUqBC,kB;;AAQnB;;;;;;;;;;;;;;;;AANA;AAqBA,gCACA;AAAA,QADYC,IACZ,uEADmB,EACnB;AAAA,QADuBC,OACvB,uEADiC,EACjC;AAAA,QADqCC,QACrC;;AAAA;;AAAA,SArBAC,KAqBA,GArBQ,WAqBR;AAAA,SAlBAC,WAkBA,GAlBc,CAkBd;;AACEH,2BACKA,OADL;AAEEI,gBAAWJ,QAAQI,QAAR,IAAoBJ,QAAQK,QAA5B,GAAuC,UAAvC,GAAoD,OAFjE;AAGEC,gBAAWN,QAAQM,QAAR,IAAoBZ;AAHjC;;AAMF,QAAI,CAACM,QAAQI,QAAb,EACA;AACC,YAAM,IAAIG,SAAJ,CAAc,yBAAd,CAAN;AACA;;AAED,QAAIP,QAAQM,QAAR,GAAmB,CAAvB,EACA;AACC,YAAM,IAAIC,SAAJ,CAAc,yBAAd,CAAN;AACA;;AAED,SAAKR,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACE,SAAKC,QAAL,GAAgBA,QAAhB;;AAEF;AACA,SAAKG,QAAL,GAAgB,mBAASJ,QAAQI,QAAjB,CAAhB;;AAEA,QAAI,CAAC,KAAKA,QAAV,EACA;AACC,YAAM,IAAIG,SAAJ,wBAAmCP,QAAQI,QAA3C,OAAN;AACA;;AAED;AACA,SAAKE,QAAL,GAAgBN,QAAQM,QAAxB;;AAEA,SAAKhB,OAAL,GAAe,IAAIE,MAAJ,CAAWF,OAAX,EAAoB,IAApB,CAAf;AACC;;AAED;;;;;;;;;AAtDA;;;;;2BA6DM;AACP;AACC;AACA;;AAEA,UAAIkB,gBAAJ;AACA,aAAQ,KAAKF,QAAL,GAAgB,CAAjB,IAAuB,CAACE,UAAU,KAAKlB,OAAL,CAAamB,IAAb,CAAkB,KAAKV,IAAvB,CAAX,MAA6C,IAA3E,EACA;AACC,YAAIW,YAAYF,QAAQ,CAAR,CAAhB;AACA,YAAMG,SAASH,QAAQI,KAAvB;;AAEAF,oBAAY,iCAAkBA,SAAlB,CAAZ;;AAEA,YAAI,mCAAoBA,SAApB,EAA+BC,MAA/B,EAAuC,KAAKZ,IAA5C,CAAJ,EACA;AACC,cAAMc;AACL;AACA,eAAKC,cAAL,CAAoBJ,SAApB,EAA+BC,MAA/B,EAAuC,KAAKZ,IAA5C;AACA;AACA;AAFA,aAGG,KAAKgB,iBAAL,CAAuBL,SAAvB,EAAkCC,MAAlC,EAA0C,KAAKZ,IAA/C,CALJ;;AAOA,cAAIc,KAAJ,EAAW;AACV,gBAAI,KAAKb,OAAL,CAAagB,EAAjB,EAAqB;AACpB,kBAAMC,cAAc,0BAAgBJ,MAAMK,OAAtB,EAA+BL,MAAMM,KAArC,EAA4C,KAAKlB,QAAL,CAAcA,QAA1D,CAApB;AACA,kBAAIY,MAAMO,GAAV,EAAe;AACdH,4BAAYG,GAAZ,GAAkBP,MAAMO,GAAxB;AACA;AACD,qBAAO;AACNC,0BAAUR,MAAMQ,QADV;AAENC,wBAAQT,MAAMS,MAFR;AAGNC,wBAAQN;AAHF,eAAP;AAKA;AACD,mBAAOJ,KAAP;AACA;AACD;;AAED,aAAKP,QAAL;AACA;AACD;;AAEA;;;;;;;sCAIkBI,S,EAAWC,M,EAAQZ,I,EACrC;AACE,2BAAgChB,aAAhC,kHACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,YADWyC,iBACX;;AACE,YAAIC,eAAe,IAAnB;AACA,YAAIjB,gBAAJ;AACA,YAAMkB,qBAAqB,IAAIlC,MAAJ,CAAWgC,iBAAX,EAA8B,GAA9B,CAA3B;AACA,eAAO,CAAChB,UAAUkB,mBAAmBjB,IAAnB,CAAwBC,SAAxB,CAAX,MAAmD,IAAnD,IAA2D,KAAKJ,QAAL,GAAgB,CAAlF,EACA;AACE,cAAImB,YAAJ,EACA;AACE;AACA,gBAAME,SAAQ,+BAEZpC,yBAFY,EAGZmB,UAAUkB,KAAV,CAAgB,CAAhB,EAAmBpB,QAAQI,KAA3B,CAHY,CAAd;;AAMA,gBAAMC,SAAQ,KAAKC,cAAL,CAAoBa,MAApB,EAA2BhB,MAA3B,EAAmCZ,IAAnC,CAAd;AACA,gBAAIc,MAAJ,EAAW;AACT,qBAAOA,MAAP;AACD;;AAED,iBAAKP,QAAL;AACAmB,2BAAe,KAAf;AACD;;AAED,cAAME,QAAQ,+BAEbpC,yBAFa,EAGbiB,QAAQ,CAAR,CAHa,CAAd;;AAMA;AACA;AACA;AACA,cAAMK,QAAQ,KAAKC,cAAL,CAAoBa,KAApB,EAA2BhB,SAASH,QAAQI,KAA5C,EAAmDb,IAAnD,CAAd;AACA,cAAIc,KAAJ,EAAW;AACT,mBAAOA,KAAP;AACD;;AAED,eAAKP,QAAL;AACD;AACF;AACF;;AAED;;;;;;;;;;;;mCASeI,S,EAAWC,M,EAAQZ,I,EAClC;AACE,UAAI,CAAC,gCAAiBW,SAAjB,EAA4BC,MAA5B,EAAoCZ,IAApC,EAA0C,KAAKC,OAAL,CAAaI,QAAvD,CAAL,EAAuE;AACrE;AACF;;AAEA,UAAMmB,SAAS,qBACbb,SADa,EACF;AACTL,kBAAU,IADD;AAETwB,wBAAgB,KAAK7B,OAAL,CAAa6B;AAFpB,OADE,EAKb,KAAK5B,QAAL,CAAcA,QALD,CAAf;;AAQA,UAAI,CAACsB,OAAOO,QAAZ,EAAsB;AACpB;AACD;;AAED,UAAI,KAAK1B,QAAL,CAAcmB,MAAd,EAAsBb,SAAtB,EAAiC,KAAKT,QAAL,CAAcA,QAA/C,CAAJ,EACA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAM8B,SAAS;AACbV,oBAAWV,MADE;AAEbW,kBAAWX,SAASD,UAAUsB,MAFjB;AAGbd,mBAAWK,OAAOL,OAHL;AAIbC,iBAAWI,OAAOJ;AAJL,SAAf;;AAOA,YAAII,OAAOH,GAAX,EAAgB;AACdW,iBAAOX,GAAP,GAAaG,OAAOH,GAApB;AACD;;AAED,eAAOW,MAAP;AACD;AACF;;;8BAGD;AACE,UAAI,KAAK7B,KAAL,KAAe,WAAnB,EACA;AACE,aAAK+B,SAAL,GAAiB,KAAKC,IAAL,EAAjB,CADF,CAC+B;;AAE7B,YAAI,KAAKD,SAAT,EACA;AACE;AACA,eAAK/B,KAAL,GAAa,OAAb;AACD,SAJD,MAMA;AACE,eAAKA,KAAL,GAAa,MAAb;AACD;AACF;;AAED,aAAO,KAAKA,KAAL,KAAe,OAAtB;AACD;;;2BAGD;AACE;AACA,UAAI,CAAC,KAAKiC,OAAL,EAAL,EACA;AACE,cAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;AACD;;AAED;AACA,UAAML,SAAS,KAAKE,SAApB;AACA,WAAKA,SAAL,GAAiB,IAAjB;AACA,WAAK/B,KAAL,GAAa,WAAb;AACA,aAAO6B,MAAP;AACD;;;;;;kBAnPkBjC,kB","file":"PhoneNumberMatcher.js","sourcesContent":["/**\r\n * A port of Google's `PhoneNumberMatcher.java`.\r\n * https://github.com/googlei18n/libphonenumber/blob/master/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberMatcher.java\r\n * Date: 08.03.2018.\r\n */\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport\r\n{\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_COUNTRY_CODE,\r\n\tVALID_PUNCTUATION,\r\n\tcreate_extension_pattern\r\n}\r\nfrom './common'\r\n\r\nimport\r\n{\r\n\tlimit,\r\n\ttrimAfterFirstMatch\r\n}\r\nfrom './findNumbers/util'\r\n\r\nimport\r\n{\r\n\t_pL,\r\n\t_pN,\r\n\tpZ,\r\n\tPZ,\r\n\tpNd\r\n}\r\nfrom './findNumbers/utf-8'\r\n\r\nimport Leniency from './findNumbers/Leniency'\r\nimport parsePreCandidate from './findNumbers/parsePreCandidate'\r\nimport isValidPreCandidate from './findNumbers/isValidPreCandidate'\r\nimport isValidCandidate, { LEAD_CLASS } from './findNumbers/isValidCandidate'\r\n\r\nimport formatNumber from './format'\r\nimport parseNumber from './parse'\r\nimport isValidNumber from './validate'\r\n\r\n/**\r\n * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are\r\n * ordered according to specificity. For example, white-space is last since that is frequently\r\n * used in numbers, not just to separate two numbers. We have separate patterns since we don't\r\n * want to break up the phone-number-like text on more than one different kind of symbol at one\r\n * time, although symbols of the same type (e.g. space) can be safely grouped together.\r\n *\r\n * Note that if there is a match, we will always check any text found up to the first match as\r\n * well.\r\n */\r\nconst INNER_MATCHES =\r\n[\r\n\t// Breaks on the slash - e.g. \"651-234-2345/332-445-1234\"\r\n\t'\\\\/+(.*)/',\r\n\r\n\t// Note that the bracket here is inside the capturing group, since we consider it part of the\r\n\t// phone number. Will match a pattern like \"(650) 223 3345 (754) 223 3321\".\r\n\t'(\\\\([^(]*)',\r\n\r\n\t// Breaks on a hyphen - e.g. \"12345 - 332-445-1234 is my number.\"\r\n\t// We require a space on either side of the hyphen for it to be considered a separator.\r\n\t`(?:${pZ}-|-${pZ})${pZ}*(.+)`,\r\n\r\n\t// Various types of wide hyphens. Note we have decided not to enforce a space here, since it's\r\n\t// possible that it's supposed to be used to break two numbers without spaces, and we haven't\r\n\t// seen many instances of it used within a number.\r\n\t`[\\u2012-\\u2015\\uFF0D]${pZ}*(.+)`,\r\n\r\n\t// Breaks on a full stop - e.g. \"12345. 332-445-1234 is my number.\"\r\n\t`\\\\.+${pZ}*([^.]+)`,\r\n\r\n\t// Breaks on space - e.g. \"3324451234 8002341234\"\r\n\t`${pZ}+(${PZ}+)`\r\n]\r\n\r\n// Limit on the number of leading (plus) characters.\r\nconst leadLimit = limit(0, 2)\r\n\r\n// Limit on the number of consecutive punctuation characters.\r\nconst punctuationLimit = limit(0, 4)\r\n\r\n/* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a\r\n * single block, set high enough to accommodate the entire national number and the international\r\n * country code. */\r\nconst digitBlockLimit = MAX_LENGTH_FOR_NSN + MAX_LENGTH_COUNTRY_CODE\r\n\r\n// Limit on the number of blocks separated by punctuation.\r\n// Uses digitBlockLimit since some formats use spaces to separate each digit.\r\nconst blockLimit = limit(0, digitBlockLimit)\r\n\r\n/* A punctuation sequence allowing white space. */\r\nconst punctuation = `[${VALID_PUNCTUATION}]` + punctuationLimit\r\n\r\n// A digits block without punctuation.\r\nconst digitSequence = pNd + limit(1, digitBlockLimit)\r\n\r\n/**\r\n * Phone number pattern allowing optional punctuation.\r\n * The phone number pattern used by `find()`, similar to\r\n * VALID_PHONE_NUMBER, but with the following differences:\r\n * <ul>\r\n *   <li>All captures are limited in order to place an upper bound to the text matched by the\r\n *       pattern.\r\n * <ul>\r\n *   <li>Leading punctuation / plus signs are limited.\r\n *   <li>Consecutive occurrences of punctuation are limited.\r\n *   <li>Number of digits is limited.\r\n * </ul>\r\n *   <li>No whitespace is allowed at the start or end.\r\n *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.\r\n * </ul>\r\n */\r\nconst PATTERN = '(?:' + LEAD_CLASS + punctuation + ')' + leadLimit\r\n\t+ digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit\r\n\t+ '(?:' + create_extension_pattern('matching') + ')?'\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// We remove all characters that are not alpha or numerical characters.\r\n// The hash character is retained here, as it may signify\r\n// the previous block was an extension.\r\n//\r\n// // Don't know what does '&&' mean here.\r\n// const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\\\P{N}&&\\\\P{L}]&&[^#]]+$`)\r\n//\r\nconst UNWANTED_END_CHAR_PATTERN = new RegExp(`[^${_pN}${_pL}#]+$`)\r\n\r\nconst NON_DIGITS_PATTERN = /(\\D+)/\r\n\r\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1\r\n\r\n/**\r\n * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.\r\n * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in\r\n * {@link PhoneNumberUtil}.\r\n *\r\n * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are\r\n * not found.\r\n *\r\n * <p>This class is not thread-safe.\r\n */\r\nexport default class PhoneNumberMatcher\r\n{\r\n  /** The iteration tristate. */\r\n  state = 'NOT_READY'\r\n\r\n  /** The next index to start searching at. Undefined in {@link State#DONE}. */\r\n  searchIndex = 0\r\n\r\n  /**\r\n   * Creates a new instance. See the factory methods in {@link PhoneNumberUtil} on how to obtain a\r\n   * new instance.\r\n   *\r\n   * @param util  the phone number util to use\r\n   * @param text  the character sequence that we will search, null for no text\r\n   * @param country  the country to assume for phone numbers not written in international format\r\n   *     (with a leading plus, or with the international dialing prefix of the specified region).\r\n   *     May be null or \"ZZ\" if only numbers with a leading plus should be\r\n   *     considered.\r\n   * @param leniency  the leniency to use when evaluating candidate phone numbers\r\n   * @param maxTries  the maximum number of invalid numbers to try before giving up on the text.\r\n   *     This is to cover degenerate cases where the text has a lot of false positives in it. Must\r\n   *     be {@code >= 0}.\r\n   */\r\n  constructor(text = '', options = {}, metadata)\r\n  {\r\n    options = {\r\n      ...options,\r\n      leniency : options.leniency || options.extended ? 'POSSIBLE' : 'VALID',\r\n      maxTries : options.maxTries || MAX_SAFE_INTEGER\r\n    }\r\n\r\n\t\tif (!options.leniency)\r\n\t\t{\r\n\t\t\tthrow new TypeError('`Leniency` not supplied')\r\n\t\t}\r\n\r\n\t\tif (options.maxTries < 0)\r\n\t\t{\r\n\t\t\tthrow new TypeError('`maxTries` not supplied')\r\n\t\t}\r\n\r\n\t\tthis.text = text\r\n\t\tthis.options = options\r\n    this.metadata = metadata\r\n\r\n\t\t/** The degree of validation requested. */\r\n\t\tthis.leniency = Leniency[options.leniency]\r\n\r\n\t\tif (!this.leniency)\r\n\t\t{\r\n\t\t\tthrow new TypeError(`Unknown leniency: ${options.leniency}.`)\r\n\t\t}\r\n\r\n\t\t/** The maximum number of retries after matching an invalid number. */\r\n\t\tthis.maxTries = options.maxTries\r\n\r\n\t\tthis.PATTERN = new RegExp(PATTERN, 'ig')\r\n  }\r\n\r\n  /**\r\n   * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}\r\n   * that represents a phone number. Returns the next match, null if none was found.\r\n   *\r\n   * @param index  the search index to start searching at\r\n   * @return  the phone number match found, null if none can be found\r\n   */\r\n\tfind() // (index)\r\n\t{\r\n\t\t// // Reset the regular expression.\r\n\t\t// this.PATTERN.lastIndex = index\r\n\r\n\t\tlet matches\r\n\t\twhile ((this.maxTries > 0) && (matches = this.PATTERN.exec(this.text)) !== null)\r\n\t\t{\r\n\t\t\tlet candidate = matches[0]\r\n\t\t\tconst offset = matches.index\r\n\r\n\t\t\tcandidate = parsePreCandidate(candidate)\r\n\r\n\t\t\tif (isValidPreCandidate(candidate, offset, this.text))\r\n\t\t\t{\r\n\t\t\t\tconst match =\r\n\t\t\t\t\t// Try to come up with a valid match given the entire candidate.\r\n\t\t\t\t\tthis.parseAndVerify(candidate, offset, this.text)\r\n\t\t\t\t\t// If that failed, try to find an \"inner match\" -\r\n\t\t\t\t\t// there might be a phone number within this candidate.\r\n\t\t\t\t\t|| this.extractInnerMatch(candidate, offset, this.text)\r\n\r\n\t\t\t\tif (match) {\r\n\t\t\t\t\tif (this.options.v2) {\r\n\t\t\t\t\t\tconst phoneNumber = new PhoneNumber(match.country, match.phone, this.metadata.metadata)\r\n\t\t\t\t\t\tif (match.ext) {\r\n\t\t\t\t\t\t\tphoneNumber.ext = match.ext\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tstartsAt: match.startsAt,\r\n\t\t\t\t\t\t\tendsAt: match.endsAt,\r\n\t\t\t\t\t\t\tnumber: phoneNumber\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn match\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.maxTries--\r\n\t\t}\r\n\t}\r\n\r\n  /**\r\n   * Attempts to extract a match from `candidate`\r\n   * if the whole candidate does not qualify as a match.\r\n   */\r\n  extractInnerMatch(candidate, offset, text)\r\n  {\r\n    for (const innerMatchPattern of INNER_MATCHES)\r\n    {\r\n      let isFirstMatch = true\r\n      let matches\r\n      const possibleInnerMatch = new RegExp(innerMatchPattern, 'g')\r\n      while ((matches = possibleInnerMatch.exec(candidate)) !== null && this.maxTries > 0)\r\n      {\r\n        if (isFirstMatch)\r\n        {\r\n          // We should handle any group before this one too.\r\n          const group = trimAfterFirstMatch\r\n          (\r\n            UNWANTED_END_CHAR_PATTERN,\r\n            candidate.slice(0, matches.index)\r\n          )\r\n\r\n          const match = this.parseAndVerify(group, offset, text)\r\n          if (match) {\r\n            return match\r\n          }\r\n\r\n          this.maxTries--\r\n          isFirstMatch = false\r\n        }\r\n\r\n        const group = trimAfterFirstMatch\r\n        (\r\n        \tUNWANTED_END_CHAR_PATTERN,\r\n        \tmatches[1]\r\n        )\r\n\r\n        // Java code does `groupMatcher.start(1)` here,\r\n        // but there's no way in javascript to get a group match start index,\r\n        // therefore using the overall match start index `matches.index`.\r\n        const match = this.parseAndVerify(group, offset + matches.index, text)\r\n        if (match) {\r\n          return match\r\n        }\r\n\r\n        this.maxTries--\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses a phone number from the `candidate` using `parseNumber` and\r\n   * verifies it matches the requested `leniency`. If parsing and verification succeed,\r\n   * a corresponding `PhoneNumberMatch` is returned, otherwise this method returns `null`.\r\n   *\r\n   * @param candidate  the candidate match\r\n   * @param offset  the offset of {@code candidate} within {@link #text}\r\n   * @return  the parsed and validated phone number match, or null\r\n   */\r\n  parseAndVerify(candidate, offset, text)\r\n  {\r\n    if (!isValidCandidate(candidate, offset, text, this.options.leniency)) {\r\n      return\r\n  \t}\r\n\r\n    const number = parseNumber(\r\n      candidate, {\r\n        extended: true,\r\n        defaultCountry: this.options.defaultCountry\r\n      },\r\n      this.metadata.metadata\r\n    )\r\n\r\n    if (!number.possible) {\r\n      return\r\n    }\r\n\r\n    if (this.leniency(number, candidate, this.metadata.metadata))\r\n    {\r\n      // // We used parseAndKeepRawInput to create this number,\r\n      // // but for now we don't return the extra values parsed.\r\n      // // TODO: stop clearing all values here and switch all users over\r\n      // // to using rawInput() rather than the rawString() of PhoneNumberMatch.\r\n      // number.clearCountryCodeSource()\r\n      // number.clearRawInput()\r\n      // number.clearPreferredDomesticCarrierCode()\r\n\r\n      const result = {\r\n        startsAt : offset,\r\n        endsAt   : offset + candidate.length,\r\n        country  : number.country,\r\n        phone    : number.phone\r\n      }\r\n\r\n      if (number.ext) {\r\n        result.ext = number.ext\r\n      }\r\n\r\n      return result\r\n    }\r\n  }\r\n\r\n  hasNext()\r\n  {\r\n    if (this.state === 'NOT_READY')\r\n    {\r\n      this.lastMatch = this.find() // (this.searchIndex)\r\n\r\n      if (this.lastMatch)\r\n      {\r\n        // this.searchIndex = this.lastMatch.endsAt\r\n        this.state = 'READY'\r\n      }\r\n      else\r\n      {\r\n        this.state = 'DONE'\r\n      }\r\n    }\r\n\r\n    return this.state === 'READY'\r\n  }\r\n\r\n  next()\r\n  {\r\n    // Check the state and find the next match as a side-effect if necessary.\r\n    if (!this.hasNext())\r\n    {\r\n      throw new Error('No next element')\r\n    }\r\n\r\n    // Don't retain that memory any longer than necessary.\r\n    const result = this.lastMatch\r\n    this.lastMatch = null\r\n    this.state = 'NOT_READY'\r\n    return result\r\n  }\r\n}"]}