'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js
var Tooltip = (_temp2 = _class = function (_PureComponent) {
	_inherits(Tooltip, _PureComponent);

	function Tooltip() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Tooltip);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.show = function () {
			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (_this.hide_timeout) {
				clearTimeout(_this.hide_timeout);
				_this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				_this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					// Not creating in `componentDidMount()`
					// therefore create it here.
					if (!_this.tooltip) {
						_this.create_tooltip();
					}

					// Play tooltip showing animation
					animate = true;
				}

			// Now that `this.tooltip` has been created,
			// re-render the component so that `ReactDOM.createPortal()` is called.
			_this.setState({ isShown: true }, function () {
				var _this$calculate_coord = _this.calculate_coordinates(),
				    x = _this$calculate_coord.x,
				    y = _this$calculate_coord.y;

				_this.tooltip.style.left = x + 'px';
				_this.tooltip.style.top = y + 'px';

				// Play tooltip showing animation
				// (doing it after setting position because
				//  setting position applies `display: block`)
				if (animate) {
					_this.tooltip.classList.add('rrui__tooltip--after-show');
				}
			});
		}, _this.hide = function () {
			var hidingAnimationDuration = _this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.
			// if (this.hide_timeout || this.tooltip.style.display === 'none')

			if (_this.hide_timeout || !_this.tooltip) {
				return;
			}

			// Play tooltip hiding animation
			_this.tooltip.classList.add('rrui__tooltip--before-hide');

			// Set the tooltip to `display: none`
			// after its hiding animation finishes.
			_this.hide_timeout = setTimeout(function () {
				_this.hide_timeout = undefined;
				_this.destroy_tooltip();
				_this.setState({ isShown: false });
			}, hidingAnimationDuration);
		}, _this.on_mouse_enter = function () {
			var content = _this.props.content;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too

			if (_this.mobile) {
				return;
			}

			// If the tooltip has no content
			// (e.g. `react-time-ago` first render)
			// or if React Portal API is not available
			// then don't show the tooltip.
			if (!content || !_reactDom2.default.createPortal) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (_this.show_timeout) {
				return;
			}

			var delay = _this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			_this.show_timeout = setTimeout(function () {
				_this.show_timeout = undefined;
				_this.show();
			}, delay);
		}, _this.on_mouse_leave = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.mobile) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (_this.show_timeout) {
				clearTimeout(_this.show_timeout);
				_this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			_this.hide();
		}, _this.on_touch_start = function () {
			var content = _this.props.content;

			// mouse enter events won't be processed from now on

			_this.mobile = true;

			// If the tooltip has no content
			// (e.g. `react-time-ago` first render)
			// or if React Portal API is not available
			// then don't show the tooltip.
			if (!content || !_reactDom2.default.createPortal) {
				return;
			}

			_this.show();
		}, _this.storeOriginNode = function (ref) {
			return _this.origin = ref;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Tooltip, [{
		key: 'componentWillUnmount',


		// componentDidMount()
		// {
		// 	this.create_tooltip()
		// }

		value: function componentWillUnmount() {
			clearTimeout(this.show_timeout);
			clearTimeout(this.hide_timeout);

			this.destroy_tooltip();
		}
	}, {
		key: 'create_tooltip',
		value: function create_tooltip() {
			var tooltipClassName = this.props.tooltipClassName;


			this.tooltip = document.createElement('div');

			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			this.tooltip.classList.add('rrui__tooltip');

			if (tooltipClassName) {
				this.tooltip.classList.add(tooltipClassName);
			}

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'destroy_tooltip',
		value: function destroy_tooltip() {
			if (this.tooltip) {
				// Won't throw an exception
				this.tooltip.parentNode.removeChild(this.tooltip);
				this.tooltip = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			var container = this.props.container;

			return container();
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = this.origin;

			var origin_width = origin.offsetWidth;

			var _offset = offset(origin);

			var top = _offset.top - height - offset(this.container()).top;
			var left = _offset.left + origin_width / 2 - width / 2;

			return reposition_within_screen(left, top, width, height);
		}
	}, {
		key: 'render',
		value: function render() {
			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			var _props = this.props,
			    content = _props.content,
			    inline = _props.inline,
			    style = _props.style,
			    className = _props.className,
			    children = _props.children;

			// `ReactDOM.createPortal()` requires React >= 16.
			// If it's not available then it won't show the tooltip.

			return _react2.default.createElement(
				'div',
				{
					ref: this.storeOriginNode,
					onMouseEnter: this.on_mouse_enter,
					onMouseLeave: this.on_mouse_leave,
					onTouchStart: this.on_touch_start,
					onTouchMove: this.hide,
					onTouchEnd: this.hide,
					onTouchCancel: this.hide,
					style: inline ? style ? _extends({}, inline_style, style) : inline_style : style,
					className: (0, _classnames2.default)('rrui__tooltip__target', className) },
				children,
				this.tooltip && content && _reactDom2.default.createPortal && _reactDom2.default.createPortal(content, this.tooltip)
			);
		}
	}]);

	return Tooltip;
}(PureComponent), _class.propTypes = {
	// Tooltip content.
	content: _propTypes2.default.node,

	// Whether this element should be displayed as `inline-block`.
	// (is `true` by default)
	inline: _propTypes2.default.bool.isRequired,

	// The delay before the tooltip is shown (in milliseconds)
	delay: _propTypes2.default.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: _propTypes2.default.number.isRequired,

	// `container: () => DOMElement` property is optional
	// and is gonna be the parent DOM Element for the tooltip itself
	// (`document.body` by default).
	// (in which case make sure that `document.body` has no `margin`
	//  otherwise tooltip `left` and `top` positions will be slightly off).
	container: _propTypes2.default.func,

	// CSS style object
	style: _propTypes2.default.object,

	// CSS class name
	className: _propTypes2.default.string,

	// Tooltip CSS class name
	tooltipClassName: _propTypes2.default.string
}, _class.defaultProps = {
	inline: true,
	delay: 200, // in milliseconds
	hidingAnimationDuration: 120, // in milliseconds
	container: function container() {
		return document.body;
	}
}, _temp2);
exports.default = Tooltip;


function reposition_within_screen(x, y, width, height) {
	var minimal_margin = 4; // in pixels

	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

// http://stackoverflow.com/questions/5598743/finding-elements-position-relative-to-the-document
function offset(element) {
	var rect = element.getBoundingClientRect();

	var client_left = document.clientLeft || document.body.clientLeft || 0;
	var client_top = document.clientTop || document.body.clientTop || 0;

	var top = rect.top + window.pageYOffset - client_top;
	var left = rect.left + window.pageXOffset - client_left;

	return { top: top, left: left };
}

var inline_style = {
	display: 'inline-block'
};
//# sourceMappingURL=Tooltip.js.map