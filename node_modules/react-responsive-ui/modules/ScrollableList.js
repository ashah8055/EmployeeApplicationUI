'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _List = require('./List');

var _List2 = _interopRequireDefault(_List);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

var ScrollableList = (_temp2 = _class = function (_PureComponent) {
	_inherits(ScrollableList, _PureComponent);

	function ScrollableList() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ScrollableList);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ScrollableList.__proto__ || Object.getPrototypeOf(ScrollableList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			// Is initialized during the first `componentDidUpdate()` call.
			verticalPadding: 0

			// Proxy `<List/>` methods.
		}, _this.focusItem = function (index) {
			return _this.list.focusItem(index);
		}, _this.focus = function () {
			return _this.list.focus();
		}, _this.unfocus = function () {
			return _this.list.unfocus();
		}, _this.onListItemsChanged = function () {
			return _this.list.onListItemsChanged();
		}, _this.onKeyDown = function (event) {
			return _this.list.onKeyDown(event);
		}, _this.getFocusedItemIndex = function () {
			return _this.list.getFocusedItemIndex();
		}, _this.focusItem = function (index) {
			return _this.list.focusItem(index);
		}, _this.onFocusItem = function (index) {
			return _this.showItem(index);
		}, _this.getListNode = function () {
			return _this.list.list;
		}, _this.storeListRef = function (ref) {
			return _this.list = ref;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ScrollableList, [{
		key: 'showItem',


		// Fully shows an option having the `value` (scrolls to it if neccessary)
		value: function showItem(index) {
			var edge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
			var children = this.props.children;


			var itemElement = this.list.itemRefs[index];

			var isFirstItem = index === 0;
			var isLastItem = index === _react2.default.Children.count(children) - 1;

			if (isFirstItem) {
				return this.showTopLine(itemElement, true);
			} else if (isLastItem) {
				return this.showBottomLine(itemElement, true);
			}

			switch (edge) {
				case 'top':
					return this.showTopLine(itemElement);
				case 'bottom':
					return this.showBottomLine(itemElement);
			}
		}
	}, {
		key: 'showTopLine',
		value: function showTopLine(itemElement, isFirstItem) {
			var verticalPadding = this.state.verticalPadding;


			var topLine = itemElement.offsetTop;

			if (isFirstItem) {
				topLine -= verticalPadding;
			}

			if (topLine < this.getListNode().scrollTop) {
				this.getListNode().scrollTop = topLine;
			}
		}
	}, {
		key: 'showBottomLine',
		value: function showBottomLine(itemElement, isLastItem) {
			var verticalPadding = this.state.verticalPadding;


			var bottomLine = itemElement.offsetTop + itemElement.offsetHeight;

			if (isLastItem) {
				bottomLine += verticalPadding;
			}

			if (bottomLine > this.getListNode().scrollTop + this.getListNode().offsetHeight) {
				this.getListNode().scrollTop = bottomLine - this.getListNode().offsetHeight;
			}
		}
	}, {
		key: 'itemOnClick',
		value: function itemOnClick(value, event) {
			var _this2 = this;

			// Collapse the `<Select/>`.
			// Doing `setValue` in a callback
			// because otherwise `setValue()` would result in
			// updating props and calling `getDerivedStateFromProps()`
			// which reads `autocomplete_value` which is being reset inside `.toggle()`.
			this.expandable.collapse().then(function () {
				return _this2.setValue(value);
			});
		}

		// Calculates height of the item list.

	}, {
		key: 'calculateHeight',
		value: function calculateHeight() {
			var children = this.props.children;


			var height = this.getListNode().scrollHeight;
			var verticalPadding = parseInt(window.getComputedStyle(this.getListNode()).paddingTop);

			var state = { height: height, verticalPadding: verticalPadding

				// Calculate the appropriate list height.
			};if (this.isOverflown()) {
				state.maxHeight = this.calculateScrollableListHeight(height, verticalPadding);
			}

			this.setState(state);
		}
	}, {
		key: 'calculateScrollableListHeight',
		value: function calculateScrollableListHeight(height, verticalPadding) {
			var _props = this.props,
			    scrollMaxItems = _props.scrollMaxItems,
			    children = _props.children;

			// Adding vertical padding here so that it shows `scrollMaxItems` items fully.
			// Also gives a peek on the `scrollMaxItems + 1`th item by showing a half of it.

			return (height - 2 * verticalPadding) * ((scrollMaxItems + 0.5) / _react2.default.Children.count(children)) + verticalPadding;
		}
	}, {
		key: 'isOverflown',
		value: function isOverflown() {
			var _props2 = this.props,
			    scrollMaxItems = _props2.scrollMaxItems,
			    children = _props2.children;

			return scrollMaxItems > 0 && _react2.default.Children.count(children) > scrollMaxItems;
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.calculateHeight();
		}
	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props,
			    scrollBarPadding = _props3.scrollBarPadding,
			    className = _props3.className,
			    children = _props3.children,
			    rest = _objectWithoutProperties(_props3, ['scrollBarPadding', 'className', 'children']);

			var maxHeight = this.state.maxHeight;


			var listStyle = void 0;

			// Makes the list scrollable if it's max height is constrained.
			if (maxHeight !== undefined) {
				listStyle = { maxHeight: maxHeight + 'px' };
			}

			return _react2.default.createElement(
				_List2.default,
				_extends({
					ref: this.storeListRef,
					onFocusItem: this.onFocusItem,
					style: listStyle,
					className: (0, _classnames2.default)(className, {
						'rrui__scrollable': this.isOverflown()
					})
				}, rest),
				children
			);
		}
	}]);

	return ScrollableList;
}(PureComponent), _class.propTypes = {
	// // A list of items.
	// items : PropTypes.arrayOf
	// (
	// 	PropTypes.shape
	// 	({
	// 		// Item value (may be `undefined`).
	// 		value : PropTypes.any,
	// 		// Item label (may be `undefined`).
	// 		label : PropTypes.string,
	// 		// Item icon component.
	// 		icon  : PropTypes.func,
	// 		// Render custom content (a React component).
	// 		// Receives `{ value, label }` properties.
	// 		content : PropTypes.func
	// 	})
	// ),

	// Maximum items fitting the list height (scrollable).
	// Set to `0` to disable overflow.
	// Is `6` by default.
	scrollMaxItems: _propTypes2.default.number.isRequired,

	// Whether should add `margin-right` for scrollbar width on overflow.
	// Is `true` by default.
	scrollBarPadding: _propTypes2.default.bool,

	className: _propTypes2.default.string
}, _class.defaultProps = {
	scrollMaxItems: 6,
	scrollBarPadding: true
}, _temp2);
exports.default = ScrollableList;
//# sourceMappingURL=ScrollableList.js.map