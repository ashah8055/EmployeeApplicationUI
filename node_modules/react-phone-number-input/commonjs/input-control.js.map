{"version":3,"sources":["../source/input-control.js"],"names":["getPreSelectedCountry","getCountrySelectOptions","parsePhoneNumber","generateNationalNumberDigits","migrateParsedInputForNewCountry","e164","trimNumber","getCountryForParsedInput","get_country_from_possibly_incomplete_international_phone_number","compare_strings","strip_country_calling_code","get_national_significant_number_part","could_number_belong_to_country","parsed_number","country","countries","includeInternationalOption","metadata","indexOf","undefined","length","country_names","country_select_options","map","value","label","sort","a","b","unshift","ZZ","parsed_phone","replace","previous_country","new_country","preferNationalFormat","derived_country","partial_national_significant_number","number","_metadata","possibleLengths","maxLength","nationalSignificantNumberPart","overflowDigitsCount","slice","parsed_input","formatter","input","String","prototype","localeCompare","country_calling_prefix","Object","keys","country_calling_codes","country_calling_code","getNationalNumber","i"],"mappings":"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","file":"input-control.js","sourcesContent":["import\r\n{\r\n\tparseNumber,\r\n\tformatNumber,\r\n\tgetCountryCallingCode,\r\n\tAsYouType,\r\n\tMetadata\r\n}\r\nfrom 'libphonenumber-js/custom'\r\n\r\n/**\r\n * Decides which country should be pre-selected\r\n * when the phone number input component is first mounted.\r\n * @param  {object} parsedNumber - A parsed number object: `{ country, phone }`. Can be an empty object.\r\n * @param  {string?} country - Pre-defined country (two-letter code).\r\n * @param  {string[]?} countries - A list of countries available.\r\n * @param  {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string?}\r\n */\r\nexport function getPreSelectedCountry(parsed_number, country, countries, includeInternationalOption, metadata)\r\n{\r\n\t// If can get country from E.164 phone number\r\n\t// then it overrides the `country` passed (or not passed).\r\n\tif (parsed_number.country)\r\n\t{\r\n\t\t// `country` will be left `undefined` in case of non-detection.\r\n\t\tcountry = parsed_number.country\r\n\t}\r\n\r\n\t// Only pre-select a country if it's in the available `countries` list.\r\n\tif (countries && countries.indexOf(country) < 0)\r\n\t{\r\n\t\tcountry = undefined\r\n\t}\r\n\r\n\t// If there will be no \"International\" option\r\n\t// then some `country` must be selected.\r\n\t// It will still be the wrong country though.\r\n\t// But still country `<select/>` can't be left in a broken state.\r\n\tif (!country && !includeInternationalOption && countries && countries.length > 0)\r\n\t{\r\n\t\tcountry = countries[0]\r\n\t}\r\n\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Generates a sorted list of country `<select/>` options.\r\n * @param  {string[]} countries - A list of two-letter (\"ISO 3166-1 alpha-2\") country codes.\r\n * @param  {object} labels - Custom country labels. E.g. `{ RU: 'Россия', US: 'США', ... }`.\r\n * @param  {boolean} includeInternationalOption - Whether should include \"International\" option at the top of the list.\r\n * @return {object[]} A list of objects having shape `{ value : string, label : string }`.\r\n */\r\nexport function getCountrySelectOptions(countries, country_names, includeInternationalOption)\r\n{\r\n\t// Generates a `<Select/>` option for each country.\r\n\tconst country_select_options = countries.map((country) =>\r\n\t({\r\n\t\tvalue : country,\r\n\t\tlabel : country_names[country]\r\n\t}))\r\n\r\n\t// Sort the list of countries alphabetically.\r\n\tcountry_select_options.sort((a, b) => compare_strings(a.label, b.label))\r\n\r\n\t// Add the \"International\" option to the country list (if suitable)\r\n\tif (includeInternationalOption)\r\n\t{\r\n\t\tcountry_select_options.unshift\r\n\t\t({\r\n\t\t\tlabel : country_names.ZZ\r\n\t\t})\r\n\t}\r\n\r\n\treturn country_select_options\r\n}\r\n\r\n/**\r\n * Parses a E.164 phone number to an object having shape `{ country : string, phone : string }`.\r\n * @param {string} value = E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @example\r\n * parsePhoneNumber('+78005553535')\r\n * // returns `{ country: 'RU', phone: '8005553535' }`\r\n */\r\nexport function parsePhoneNumber(value, metadata)\r\n{\r\n\treturn parseNumber(value || '', metadata)\r\n}\r\n\r\n/**\r\n * Generates national number digits for a parsed phone.\r\n * May prepend national prefix.\r\n * The phone number must be a complete and valid phone number.\r\n * @param  {object} parsedPhone - Object having shape `{ country : string, phone : string }`.\r\n * @param  {object} metadata - `libphonenumber-js` metadata\r\n * @return {string}\r\n * @example\r\n * getNationalNumberDigits({ country: 'RU', phone: '8005553535' })\r\n * // returns '88005553535'\r\n */\r\nexport function generateNationalNumberDigits(parsed_phone, metadata)\r\n{\r\n\treturn formatNumber(parsed_phone, 'National', metadata).replace(/\\D/g, '')\r\n}\r\n\r\n/**\r\n * Migrates `<input/>` parsed `value` for the newly selected `country`.\r\n * @param {string?} value - The `value` parsed from phone number `<input/>` (it's the `parsed_input` state property, not the `value` property).\r\n * @param {string?} previousCountry - Previously selected country.\r\n * @param {string?} newCountry - Newly selected country. Can't be same as previously selected country.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @param {boolean} preferNationalFormat - whether should attempt to convert from international to national number for the new country.\r\n * @return {string}\r\n */\r\nexport function migrateParsedInputForNewCountry\r\n(\r\n\tvalue,\r\n\tprevious_country,\r\n\tnew_country,\r\n\tmetadata,\r\n\tpreferNationalFormat\r\n)\r\n{\r\n\t// If `parsed_input` is empty\r\n\t// then no need to migrate anything.\r\n\tif (!value) {\r\n\t\treturn value\r\n\t}\r\n\r\n\t// If switching to some country.\r\n\t// (from \"International\" or another country)\r\n\t// If switching from \"International\" then `value` starts with a `+`.\r\n\t// Otherwise it may or may not start with a `+`.\r\n\tif (new_country)\r\n\t{\r\n\t\t// If the phone number was entered in international format\r\n\t\t// then migrate it to the newly selected country.\r\n\t\t// The phone number may be incomplete.\r\n\t\t// The phone number entered not necessarily starts with\r\n\t\t// the previously selected country phone prefix.\r\n\t\tif (value[0] === '+')\r\n\t\t{\r\n\t\t\t// If the international phone number is for the new country\r\n\t\t\t// then convert it to local if required.\r\n\t\t\tif (preferNationalFormat)\r\n\t\t\t{\r\n\t\t\t\t// If a phone number is being input in international form\r\n\t\t\t\t// and the country can already be derived from it,\r\n\t\t\t\t// and if it is the new country, then format as a national number.\r\n\t\t\t\tconst derived_country = get_country_from_possibly_incomplete_international_phone_number(value, metadata)\r\n\t\t\t\tif (derived_country === new_country)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn strip_country_calling_code(value, derived_country, metadata)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// If the international phone number already contains\r\n\t\t\t// any country calling code then trim the country calling code part.\r\n\t\t\t// (that could also be the newly selected country phone code prefix as well)\r\n\t\t\t// `value` doesn't neccessarily belong to `previous_country`.\r\n\t\t\t// (e.g. if a user enters an international number\r\n\t\t\t//  not belonging to any of the reduced `countries` list)\r\n\t\t\tvalue = strip_country_calling_code(value, previous_country, metadata)\r\n\r\n\t\t\t// Prepend country calling code prefix\r\n\t\t\t// for the newly selected country.\r\n\t\t\treturn `+${getCountryCallingCode(new_country, metadata)}${value}`\r\n\t\t}\r\n\t}\r\n\t// If switching to \"International\" from a country.\r\n\telse\r\n\t{\r\n\t\t// If the phone number was entered in national format.\r\n\t\tif (value[0] !== '+')\r\n\t\t{\r\n\t\t\t// Format the national phone number as an international one.\r\n\t\t\t// The phone number entered not necessarily even starts with\r\n\t\t\t// the previously selected country phone prefix.\r\n\t\t\t// Even if the phone number belongs to whole another country\r\n\t\t\t// it will still be parsed into some national phone number.\r\n\t\t\tconst partial_national_significant_number = get_national_significant_number_part(value, previous_country, metadata)\r\n\t\t\treturn formatNumber(partial_national_significant_number, previous_country, 'E.164', metadata)\r\n\t\t}\r\n\t}\r\n\r\n\treturn value\r\n}\r\n\r\n/**\r\n * Converts phone number digits to a (possibly incomplete) E.164 phone number.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function e164(number, country, metadata)\r\n{\r\n\tif (!number) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// If the phone number is being input in international format.\r\n\tif (number[0] === '+')\r\n\t{\r\n\t\t// If it's just the `+` sign then return nothing.\r\n\t\tif (number === '+') {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// If there are any digits then the `value` is returned as is.\r\n\t\treturn number\r\n\t}\r\n\r\n\t// For non-international phone numbers\r\n\t// an accompanying country code is required.\r\n\tif (!country) {\r\n\t\treturn\r\n\t}\r\n\r\n\tconst partial_national_significant_number = get_national_significant_number_part(number, country, metadata)\r\n\r\n\tif (partial_national_significant_number) {\r\n\t\treturn formatNumber(partial_national_significant_number, country, 'E.164', metadata)\r\n\t}\r\n}\r\n\r\n/**\r\n * Trims phone number digits if they exceed the maximum possible length\r\n * for a national (significant) number for the country.\r\n * @param  {string?} number - A possibly incomplete phone number digits string. Can be a possibly incomplete E.164 phone number.\r\n * @param  {string?} country\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function trimNumber(number, country, metadata)\r\n{\r\n\tif (!number || !country) {\r\n\t\treturn number\r\n\t}\r\n\r\n\tconst _metadata = new Metadata(metadata)\r\n\t_metadata.country(country)\r\n\tconst possibleLengths = _metadata.possibleLengths()\r\n\r\n\tconst maxLength = possibleLengths[possibleLengths.length - 1]\r\n\tconst nationalSignificantNumberPart = get_national_significant_number_part(number, country, metadata)\r\n\tconst overflowDigitsCount = nationalSignificantNumberPart.length - maxLength\r\n\tif (overflowDigitsCount > 0) {\r\n\t\treturn number.slice(0, number.length - overflowDigitsCount)\r\n\t}\r\n\r\n\treturn number\r\n}\r\n\r\n// If the phone number being input is an international one\r\n// then tries to derive the country from the phone number.\r\n// (regardless of whether there's any country currently selected)\r\n/**\r\n * @param {string} parsedInput - A possibly incomplete E.164 phone number.\r\n * @param {string?} country - Currently selected country.\r\n * @param {string[]?} countries - A list of available countries. If not passed then \"all countries\" are assumed.\r\n * @param {boolean} includeInternationalOption - Whether \"International\" country option is available.\r\n * @param  {[object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function getCountryForParsedInput\r\n(\r\n\tparsed_input,\r\n\tcountry,\r\n\tcountries,\r\n\tincludeInternationalOption,\r\n\tmetadata\r\n)\r\n{\r\n\tif (parsed_input === '+')\r\n\t{\r\n\t\t// Don't change the currently selected country yet.\r\n\t\treturn country\r\n\t}\r\n\r\n\tconst derived_country = get_country_from_possibly_incomplete_international_phone_number(parsed_input, metadata)\r\n\r\n\t// If a phone number is being input in international form\r\n\t// and the country can already be derived from it,\r\n\t// then select that country.\r\n\tif (derived_country && (!countries || (countries.indexOf(derived_country) >= 0)))\r\n\t{\r\n\t\treturn derived_country\r\n\t}\r\n\t// If \"International\" country option has not been disabled\r\n\t// and the international phone number entered doesn't correspond\r\n\t// to the currently selected country then reset the currently selected country.\r\n\telse if (country &&\r\n\t\tincludeInternationalOption &&\r\n\t\t!could_number_belong_to_country(parsed_input, country, metadata))\r\n\t{\r\n\t\treturn undefined\r\n\t}\r\n\r\n\t// Don't change the currently selected country.\r\n\treturn country\r\n}\r\n\r\n/**\r\n * Determines the country for a given (possibly incomplete) E.164 phone number.\r\n * @param  {string} number - A possibly incomplete E.164 phone number.\r\n * @param  {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string?}\r\n */\r\nexport function get_country_from_possibly_incomplete_international_phone_number(number, metadata)\r\n{\r\n\tconst formatter = new AsYouType(null, metadata)\r\n\tformatter.input(number)\r\n\t// `001` is a special \"non-geograpical entity\" code\r\n\t// in Google's `libphonenumber` library.\r\n\tif (formatter.country === '001') {\r\n\t\treturn\r\n\t}\r\n\treturn formatter.country\r\n}\r\n\r\n/**\r\n * Compares two strings.\r\n * A helper for `Array.sort()`.\r\n */\r\nexport function compare_strings(a, b) {\r\n  // Use `String.localeCompare` if it's available.\r\n  // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\r\n  // Which means everyone except IE <= 10 and Safari <= 10.\r\n  // `localeCompare()` is available in latest Node.js versions.\r\n  /* istanbul ignore else */\r\n  if (String.prototype.localeCompare) {\r\n    return a.localeCompare(b);\r\n  }\r\n  /* istanbul ignore next */\r\n  return a < b ? -1 : (a > b ? 1 : 0);\r\n}\r\n\r\n/**\r\n * Strips `+${countryCallingCode}` prefix from an E.164 phone number.\r\n * @param {string} number - (possibly incomplete) E.164 phone number.\r\n * @param {string?} country - A possible country for this phone number.\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n * @return {string}\r\n */\r\nexport function strip_country_calling_code(number, country, metadata)\r\n{\r\n\t// Just an optimization, so that it\r\n\t// doesn't have to iterate through all country calling codes.\r\n\tif (country)\r\n\t{\r\n\t\tconst country_calling_prefix = '+' + getCountryCallingCode(country, metadata)\r\n\r\n\t\t// If `country` fits the actual `number`.\r\n\t\tif (number.length < country_calling_prefix.length)\r\n\t\t{\r\n\t\t\tif (country_calling_prefix.indexOf(number) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn ''\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (number.indexOf(country_calling_prefix) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn number.slice(country_calling_prefix.length)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If `country` doesn't fit the actual `number`.\r\n\t// Try all available country calling codes.\r\n\tfor (const country_calling_code of Object.keys(metadata.country_calling_codes))\r\n\t{\r\n\t\tif (number.indexOf(country_calling_code) === '+'.length)\r\n\t\t{\r\n\t\t\treturn number.slice('+'.length + country_calling_code.length)\r\n\t\t}\r\n\t}\r\n\r\n\treturn ''\r\n}\r\n\r\n/**\r\n * Parses a partially entered national phone number digits\r\n * (or a partially entered E.164 international phone number)\r\n * and returns the national significant number part.\r\n * National significant number returned doesn't come with a national prefix.\r\n * @param {string} number - National number digits. Or possibly incomplete E.164 phone number.\r\n * @param {string?} country\r\n * @param {object} metadata - `libphonenumber-js` metadata.\r\n */\r\nexport function get_national_significant_number_part(number, country, metadata)\r\n{\r\n\t// Create \"as you type\" formatter.\r\n\tconst formatter = new AsYouType(country, metadata)\r\n\r\n\t// Input partial national phone number.\r\n\tformatter.input(number)\r\n\r\n\t// Return the parsed partial national phone number.\r\n\treturn formatter.getNationalNumber()\r\n}\r\n\r\n/**\r\n * Checks if a partially entered E.164 phone number could belong to a country.\r\n * @param  {string} number\r\n * @param  {string} country\r\n * @return {boolean}\r\n */\r\nexport function could_number_belong_to_country(number, country, metadata)\r\n{\r\n\tconst country_calling_code = getCountryCallingCode(country, metadata)\r\n\r\n\tlet i = 0\r\n\twhile (i + 1 < number.length && i < country_calling_code.length)\r\n\t{\r\n\t\tif (number[i + 1] !== country_calling_code[i])\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\treturn true\r\n}"]}