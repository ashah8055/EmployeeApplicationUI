{"version":3,"sources":["../source/getNumberType.js"],"names":["parse","is_viable_phone_number","matches_entirely","Metadata","non_fixed_line_types","get_number_type","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","input","options","metadata","country","hasCountry","Error","nationalNumber","v2","phone","nationalNumberPattern","is_of_type","type","pattern","_type","possibleLengths","indexOf","length","is_object","TypeError","check_number_length_for_type","type_info","possible_lengths","mobile_type","merge_arrays","actual_length","minimum_length","_","a","b","merged","slice","element","push","sort"],"mappings":"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","file":"getNumberType.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\r\n\r\nimport { matches_entirely } from './common'\r\n\r\nimport Metadata from './metadata'\r\n\r\nconst non_fixed_line_types =\r\n[\r\n\t'MOBILE',\r\n\t'PREMIUM_RATE',\r\n\t'TOLL_FREE',\r\n\t'SHARED_COST',\r\n\t'VOIP',\r\n\t'PERSONAL_NUMBER',\r\n\t'PAGER',\r\n\t'UAN',\r\n\t'VOICEMAIL'\r\n]\r\n\r\n// Finds out national phone number type (fixed line, mobile, etc)\r\nexport default function get_number_type(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { input, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\t// When `parse()` returned `{}`\r\n\t// meaning that the phone number is not a valid one.\r\n\tif (!input.country)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tif (!metadata.hasCountry(input.country))\r\n\t{\r\n\t\tthrow new Error(`Unknown country: ${input.country}`)\r\n\t}\r\n\r\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\r\n\tmetadata.country(input.country)\r\n\r\n\t// The following is copy-pasted from the original function:\r\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\r\n\r\n\t// Is this national number even valid for this country\r\n\tif (!matches_entirely(nationalNumber, metadata.nationalNumberPattern()))\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\t// Is it fixed line number\r\n\tif (is_of_type(nationalNumber, 'FIXED_LINE', metadata))\r\n\t{\r\n\t\t// Because duplicate regular expressions are removed\r\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\r\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\r\n\t\t//\r\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// v1 metadata.\r\n\t\t// Legacy.\r\n\t\t// Deprecated.\r\n\t\tif (!metadata.type('MOBILE'))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\r\n\t\t// (no such country in the minimal metadata set)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (is_of_type(nationalNumber, 'MOBILE', metadata))\r\n\t\t{\r\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\r\n\t\t}\r\n\r\n\t\treturn 'FIXED_LINE'\r\n\t}\r\n\r\n\tfor (const _type of non_fixed_line_types)\r\n\t{\r\n\t\tif (is_of_type(nationalNumber, _type, metadata))\r\n\t\t{\r\n\t\t\treturn _type\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function is_of_type(nationalNumber, type, metadata)\r\n{\r\n\ttype = metadata.type(type)\r\n\r\n\tif (!type || !type.pattern())\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Check if any possible number lengths are present;\r\n\t// if so, we use them to avoid checking\r\n\t// the validation pattern if they don't match.\r\n\t// If they are absent, this means they match\r\n\t// the general description, which we have\r\n\t// already checked before a specific number type.\r\n\tif (type.possibleLengths() &&\r\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0)\r\n\t{\r\n\t\treturn false\r\n\t}\r\n\r\n\treturn matches_entirely(nationalNumber, type.pattern())\r\n}\r\n\r\n// Sort out arguments\r\nexport function sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tlet input\r\n\tlet options = {}\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `getNumberType('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\t// If \"default country\" argument is being passed\r\n\t\t// then convert it to an `options` object.\r\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\r\n\t\tif (typeof arg_2 !== 'object')\r\n\t\t{\r\n\t\t\tif (arg_4)\r\n\t\t\t{\r\n\t\t\t\toptions = arg_3\r\n\t\t\t\tmetadata = arg_4\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmetadata = arg_3\r\n\t\t\t}\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, arg_2, metadata)\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tinput = {}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// No \"resrict country\" argument is being passed.\r\n\t\t// International phone number is passed.\r\n\t\t// `getNumberType('+78005553535', metadata)`.\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (arg_3)\r\n\t\t\t{\r\n\t\t\t\toptions = arg_2\r\n\t\t\t\tmetadata = arg_3\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmetadata = arg_2\r\n\t\t\t}\r\n\r\n\t\t\t// `parse` extracts phone numbers from raw text,\r\n\t\t\t// therefore it will cut off all \"garbage\" characters,\r\n\t\t\t// while this `validate` function needs to verify\r\n\t\t\t// that the phone number contains no \"garbage\"\r\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\r\n\t\t\tif (is_viable_phone_number(arg_1))\r\n\t\t\t{\r\n\t\t\t\tinput = parse(arg_1, metadata)\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tinput = {}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// If the phone number is passed as a parsed phone number.\r\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\r\n\telse if (is_object(arg_1))\r\n\t{\r\n\t\tinput = arg_1\r\n\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\r\n\r\n\treturn { input, options, metadata: new Metadata(metadata) }\r\n}\r\n\r\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\r\nexport function check_number_length_for_type(nationalNumber, type, metadata)\r\n{\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE')\r\n\t{\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE'))\r\n\t\t{\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\r\n\t\t\treturn check_number_length_for_type(nationalNumber, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\r\n\t\tif (mobile_type)\r\n\t\t{\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = merge_arrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths)\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = merge_arrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// }\r\n\t\t\t// else\r\n\t\t\t// {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info)\r\n\t{\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length)\r\n\t{\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length)\r\n\t{\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\r\n\t{\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst is_object = _ => typeof _ === 'object'\r\n\r\nexport function merge_arrays(a, b)\r\n{\r\n\tconst merged = a.slice()\r\n\r\n\tfor (const element of b)\r\n\t{\r\n\t\tif (a.indexOf(element) < 0)\r\n\t\t{\r\n\t\t\tmerged.push(element)\r\n\t\t}\r\n\t}\r\n\r\n\treturn merged.sort((a, b) => a - b)\r\n\r\n\t// ES6 version, requires Set polyfill.\r\n\t// let merged = new Set(a)\r\n\t// for (const element of b)\r\n\t// {\r\n\t// \tmerged.add(i)\r\n\t// }\r\n\t// return Array.from(merged).sort((a, b) => a - b)\r\n}"]}