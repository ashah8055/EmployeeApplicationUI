{"version":3,"sources":["../../source/findNumbers/Leniency.js"],"names":["parseNumber","isValidNumber","parseDigit","startsWith","endsWith","POSSIBLE","number","candidate","metadata","VALID","containsOnlyValidXChars","toString","STRICT_GROUPING","candidateString","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","allNumberGroupsAreExactlyPresent","index","length","charAtIndex","charAt","charAtNextIndex","util","isNumberMatch","substring","MatchType","NSN_MATCH","parseDigits","ext","_metadata","getCountryCodeSource","phoneNumberRegion","getRegionCodeForCountryCode","getCountryCode","getMetadataForRegion","nationalNumber","getNationalSignificantNumber","formatRule","chooseFormattingPatternForNumber","numberFormats","getNationalPrefixFormattingRule","getNationalPrefixOptionalWhenFormatting","PhoneNumberUtil","formattingRuleHasFirstGroupOnly","rawInputCopy","normalizeDigitsOnly","getRawInput","maybeStripNationalPrefixAndCarrierCode","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","candidateHasCountryCode","CountryCodeSource","FROM_NUMBER_WITH_PLUS_SIGN","FROM_NUMBER_WITHOUT_PLUS_SIGN","String","slice","checkGroups","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","alternateFormats","MetadataManager","getAlternateFormatsForCountry","alternateFormat","formattingPattern","nationalSignificantNumber","formatNsnUsingPattern","split","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","NON_DIGITS_PATTERN","candidateNumberGroupIndex","hasExtension","contains","formattedNumberGroupIndex","fromIndex","FROM_DEFAULT_COUNTRY","countryCode","i","region","getNddPrefixForRegion","Character","isDigit","getExtension","string","result","character","digit"],"mappings":"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","file":"Leniency.js","sourcesContent":["import parseNumber from '../parse'\r\nimport isValidNumber from '../validate'\r\nimport { parseDigit } from '../common'\r\n\r\nimport\r\n{\r\n\tstartsWith,\r\n\tendsWith\r\n}\r\nfrom './util'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(number, candidate, metadata)\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(number, candidate, metadata)\r\n\t{\r\n\t\tif (!isValidNumber(number, metadata) ||\r\n\t\t\t!containsOnlyValidXChars(number, candidate.toString(), metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n    // Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(number, metadata)\r\n    return true\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(number, candidate, metadata)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped\r\n\t\t)\r\n  },\r\n\r\n\t/**\r\n\t * Phone numbers accepted are {@linkplain PhoneNumberUtil#isValidNumber(PhoneNumber) valid} and\r\n\t * are grouped in the same way that we would have formatted it, or as a single block. For\r\n\t * example, a US number written as \"650 2530000\" is not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t * <p>\r\n\t * Warning: This level might result in lower coverage especially for regions outside of country\r\n\t * code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(number, candidate, metadata)\r\n\t{\r\n\t\tconst candidateString = candidate.toString()\r\n\r\n\t\tif (!isValidNumber(number, metadata)\r\n\t\t\t|| !containsOnlyValidXChars(number, candidateString, metadata)\r\n\t\t\t|| containsMoreThanOneSlashInNationalNumber(number, candidateString)\r\n\t\t\t|| !isNationalPrefixPresentIfRequired(number, metadata))\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tnumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n   \t\tallNumberGroupsAreExactlyPresent\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(number, candidate, metadata)\r\n{\r\n  // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n  // national significant number or (2) an extension sign, in which case they always precede the\r\n  // extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n  // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n  // or 'X'. We ignore the character if it appears as the last character of the string.\r\n  for (let index = 0; index < candidate.length - 1; index++)\r\n  {\r\n    const charAtIndex = candidate.charAt(index)\r\n\r\n    if (charAtIndex === 'x' || charAtIndex === 'X')\r\n    {\r\n      const charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n      if (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n      {\r\n        // This is the carrier code case, in which the 'X's always precede the national\r\n        // significant number.\r\n        index++\r\n        if (util.isNumberMatch(number, candidate.substring(index)) != MatchType.NSN_MATCH)\r\n        {\r\n          return false\r\n        }\r\n\t      // This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t      // extension number.\r\n      }\r\n      else if (parseDigits(candidate.substring(index)) !== number.ext)\r\n      {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(number, _metadata)\r\n{\r\n  // First, check how we deduced the country code. If it was written in international format, then\r\n  // the national prefix is not required.\r\n  if (number.getCountryCodeSource() != 'FROM_DEFAULT_COUNTRY')\r\n  {\r\n    return true\r\n  }\r\n\r\n  const phoneNumberRegion = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\r\n  const metadata = util.getMetadataForRegion(phoneNumberRegion)\r\n  if (metadata == null)\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Check if a national prefix should be present when formatting this number.\r\n  const nationalNumber = util.getNationalSignificantNumber(number)\r\n  const formatRule = util.chooseFormattingPatternForNumber(metadata.numberFormats(), nationalNumber)\r\n\r\n  // To do this, we check that a national prefix formatting rule was present\r\n  // and that it wasn't just the first-group symbol ($1) with punctuation.\r\n  if (formatRule && formatRule.getNationalPrefixFormattingRule().length > 0)\r\n  {\r\n    if (formatRule.getNationalPrefixOptionalWhenFormatting())\r\n    {\r\n      // The national-prefix is optional in these cases, so we don't need to check if it was\r\n      // present.\r\n      return true\r\n    }\r\n\r\n    if (PhoneNumberUtil.formattingRuleHasFirstGroupOnly(\r\n        formatRule.getNationalPrefixFormattingRule()))\r\n    {\r\n      // National Prefix not needed for this number.\r\n      return true\r\n    }\r\n\r\n    // Normalize the remainder.\r\n    const rawInputCopy = PhoneNumberUtil.normalizeDigitsOnly(number.getRawInput())\r\n\r\n    // Check if we found a national prefix and/or carrier code at the start of the raw input, and\r\n    // return the result.\r\n    return util.maybeStripNationalPrefixAndCarrierCode(rawInputCopy, metadata, null)\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(number, candidate)\r\n{\r\n  const firstSlashInBodyIndex = candidate.indexOf('/')\r\n  if (firstSlashInBodyIndex < 0)\r\n  {\r\n    // No slashes, this is okay.\r\n    return false\r\n  }\r\n\r\n  // Now look for a second one.\r\n  const secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n  if (secondSlashInBodyIndex < 0)\r\n  {\r\n    // Only one slash, this is okay.\r\n    return false\r\n  }\r\n\r\n  // If the first slash is after the country calling code, this is permitted.\r\n  const candidateHasCountryCode =\r\n      (number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN\r\n       || number.getCountryCodeSource() === CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN)\r\n\r\n  if (candidateHasCountryCode\r\n      && PhoneNumberUtil.normalizeDigitsOnly(candidate.substring(0, firstSlashInBodyIndex))\r\n          === String(number.getCountryCode()))\r\n  {\r\n    // Any more slashes and this is illegal.\r\n    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid\r\n(\r\n  number,\r\n  candidate,\r\n  metadata,\r\n  checkGroups\r\n)\r\n{\r\n  // TODO: Evaluate how this works for other locales (testing has been limited to NANPA regions)\r\n  // and optimise if necessary.\r\n  const normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n  let formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n  if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups))\r\n  {\r\n    return true\r\n  }\r\n\r\n  // If this didn't pass, see if there are any alternate formats, and try them instead.\r\n  const alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n\r\n  if (alternateFormats)\r\n  {\r\n    for (const alternateFormat of alternateFormats.numberFormats())\r\n    {\r\n      formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n\r\n      if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together.\r\n */\r\nfunction getNationalNumberGroups\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n)\r\n{\r\n  if (formattingPattern)\r\n  {\r\n    // We format the NSN only, and split that according to the separator.\r\n    const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n    return util.formatNsnUsingPattern(nationalSignificantNumber,\r\n                                      formattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n  // This will be in the format +CC-DG;ext=EXT where DG represents groups of digits.\r\n  const rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n  // We remove the extension part from the formatted string before splitting it into different\r\n  // groups.\r\n  let endIndex = rfc3966Format.indexOf(';')\r\n  if (endIndex < 0) {\r\n    endIndex = rfc3966Format.length\r\n  }\r\n\r\n  // The country-code will have a '-' following it.\r\n  const startIndex = rfc3966Format.indexOf('-') + 1\r\n  return rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  const candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n  // Set this to the last group, skipping it if the number has an extension.\r\n  let candidateNumberGroupIndex =\r\n      number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n  // First we check if the national significant number is formatted as a block.\r\n  // We use contains and not equals, since the national significant number may be present with\r\n  // a prefix such as a national number prefix, or the country code itself.\r\n  if (candidateGroups.length == 1\r\n      || candidateGroups[candidateNumberGroupIndex].contains(\r\n          util.getNationalSignificantNumber(number)))\r\n  {\r\n    return true\r\n  }\r\n\r\n  // Starting from the end, go through in reverse, excluding the first group, and check the\r\n  // candidate and number groups are the same.\r\n  let formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n  while (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n  {\r\n    if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n    {\r\n      return false\r\n    }\r\n    formattedNumberGroupIndex--\r\n    candidateNumberGroupIndex--\r\n  }\r\n\r\n  // Now check the first group. There may be a national prefix at the start, so we only check\r\n  // that the candidate group ends with the formatted number group.\r\n  return (candidateNumberGroupIndex >= 0\r\n      && endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n  let fromIndex = 0\r\n  if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n  {\r\n    // First skip the country code if the normalized candidate contained it.\r\n    const countryCode = String(number.getCountryCode())\r\n    fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n  }\r\n\r\n  // Check each group of consecutive digits are not broken into separate groupings in the\r\n  // {@code normalizedCandidate} string.\r\n  for (let i = 0; i < formattedNumberGroups.length; i++)\r\n  {\r\n    // Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n    // doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n    fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n    if (fromIndex < 0) {\r\n      return false\r\n    }\r\n    // Moves {@code fromIndex} forward.\r\n    fromIndex += formattedNumberGroups[i].length()\r\n    if (i == 0 && fromIndex < normalizedCandidate.length())\r\n    {\r\n      // We are at the position right after the NDC. We get the region used for formatting\r\n      // information based on the country code in the phone number, rather than the number itself,\r\n      // as we do not need to distinguish between different countries with the same country\r\n      // calling code and this is faster.\r\n      const region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n      if (util.getNddPrefixForRegion(region, true) != null\r\n          && Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n        // This means there is no formatting symbol after the NDC. In this case, we only\r\n        // accept the number if there is no formatting symbol at all in the number, except\r\n        // for extensions. This is only important for countries with national prefixes.\r\n        const nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n        return startsWith\r\n        (\r\n      \t  normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n           nationalSignificantNumber\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  // The check here makes sure that we haven't mistakenly already used the extension to\r\n  // match the last group of the subscriber number. Note the extension cannot have\r\n  // formatting in-between digits.\r\n  return normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}\r\n\r\nfunction parseDigits(string)\r\n{\r\n  let result = ''\r\n\r\n  // Using `.split('')` here instead of normal `for ... of`\r\n  // because the importing application doesn't neccessarily include an ES6 polyfill.\r\n  // The `.split('')` approach discards \"exotic\" UTF-8 characters\r\n  // (the ones consisting of four bytes) but digits\r\n  // (including non-European ones) don't fall into that range\r\n  // so such \"exotic\" characters would be discarded anyway.\r\n  for (const character of string.split(''))\r\n  {\r\n    const digit = parseDigit(character)\r\n    if (digit) {\r\n      result += digit\r\n    }\r\n  }\r\n\r\n  return result\r\n}"]}