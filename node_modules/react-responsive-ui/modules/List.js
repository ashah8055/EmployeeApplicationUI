'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Item = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _class2, _temp2, _class3, _temp4;

exports.findItemIndexByValue = findItemIndexByValue;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _reactLifecyclesCompat = require('react-lifecycles-compat');

var _Divider = require('./Divider');

var _Divider2 = _interopRequireDefault(_Divider);

var _dom = require('./utility/dom');

var _focus = require('./utility/focus');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

// Workaround for `react-hot-loader`.
// https://github.com/gaearon/react-hot-loader#checking-element-types
var DividerType = _react2.default.createElement(_Divider2.default, null).type;

var List = (0, _reactLifecyclesCompat.polyfill)(_class = (_temp2 = _class2 = function (_PureComponent) {
	_inherits(List, _PureComponent);

	function List() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, List);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.itemRefs = [], _this.getFocusedItemIndex = function () {
			var focusedItemIndex = _this.state.focusedItemIndex;


			return focusedItemIndex;
		}, _this.unfocus = function () {
			_this.setState({
				focusedItemIndex: undefined,
				focusedItemValue: undefined
			});
		}, _this.focus = function () {
			var focusedItemIndex = _this.state.focusedItemIndex;


			if (focusedItemIndex !== undefined) {
				return _this.focusItem(focusedItemIndex);
			}

			// Focus the first focusable list item.
			_this.focusItem(_this.getFirstFocusableItemIndex());
		}, _this.focusItem = function (focusedItemIndex) {
			var _this$props = _this.props,
			    onFocusItem = _this$props.onFocusItem,
			    shouldFocus = _this$props.shouldFocus;


			_this.setState({
				// Focus the item.
				focusedItemIndex: focusedItemIndex,
				// Store the focused item value.
				// This is used for cases like autocomplete
				// where the list of options changes but
				// the focused option stays focused.
				focusedItemValue: focusedItemIndex === undefined ? undefined : _this.getItemValue(focusedItemIndex)
			}, function () {
				if (focusedItemIndex !== undefined) {
					if (shouldFocus) {
						(0, _focus.focus)(_this.itemRefs[focusedItemIndex]);
					}

					if (onFocusItem) {
						onFocusItem(focusedItemIndex);
					}
				}
			});
		}, _this.onKeyDown = function (event) {
			var _this$props2 = _this.props,
			    onKeyDown = _this$props2.onKeyDown,
			    children = _this$props2.children;
			var focusedItemIndex = _this.state.focusedItemIndex;


			if (onKeyDown) {
				onKeyDown(event);
			}

			if (event.defaultPrevented) {
				return;
			}

			if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {
				return;
			}

			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			if (_react2.default.Children.count(children) > 0) {
				switch (event.keyCode) {
					// "Up" arrow.
					// Select the previous item (if present).
					case 38:
						event.preventDefault();

						var previousIndex = _this.getPreviousFocusableItemIndex();

						if (previousIndex !== undefined) {
							_this.focusItem(previousIndex);
						}

						return;

					// "Down" arrow.
					// Select the next item (if present).
					case 40:
						event.preventDefault();

						var nextIndex = _this.getNextFocusableItemIndex();

						if (nextIndex !== undefined) {
							_this.focusItem(nextIndex);
						}

						return;

					// "Enter".
					case 13:
						// Choose the focused item on Enter
						event.preventDefault();

						if (focusedItemIndex !== undefined) {
							_this.itemRefs[focusedItemIndex].click();
						}

						return;

					// "Spacebar".
					case 32:
						// Choose the focused item on Spacebar.
						if (focusedItemIndex !== undefined) {
							if (_this.itemRefs[focusedItemIndex].tagName.toLowerCase() !== 'button') {
								event.preventDefault();
								_this.itemRefs[focusedItemIndex].click();
							}
						}

						return;
				}
			}
		}, _this.isFocusableItemIndex = function (index) {
			return _this.itemRefs[index] !== undefined;
		}, _this.isFocusableItem = function (item) {
			return item.type !== DividerType;
		}, _this.storeListNode = function (node) {
			return _this.list = node;
		}, _this.storeItemRef = function (ref, i) {
			return _this.itemRefs[i] = ref;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(List, [{
		key: 'getFirstFocusableItemIndex',
		value: function getFirstFocusableItemIndex() {
			var i = 0;
			while (i < this.itemRefs.length) {
				if (this.itemRefs[i]) {
					return i;
				}
			}
		}
	}, {
		key: 'getItemValue',
		value: function getItemValue(index) {
			var children = this.props.children;


			var item = _react2.default.Children.toArray(children)[index];
			return item.props.value;
		}
	}, {
		key: 'getPreviousFocusableItemIndex',


		// Get the previous option (relative to the currently focused option)
		value: function getPreviousFocusableItemIndex() {
			var children = this.props.children;
			var focusedItemIndex = this.state.focusedItemIndex;


			if (focusedItemIndex === undefined) {
				focusedItemIndex = _react2.default.Children.count(children);
			}

			while (focusedItemIndex > 0) {
				focusedItemIndex--;
				if (this.isFocusableItemIndex(focusedItemIndex)) {
					return focusedItemIndex;
				}
			}
		}

		// Get the next option (relative to the currently focused option)

	}, {
		key: 'getNextFocusableItemIndex',
		value: function getNextFocusableItemIndex() {
			var children = this.props.children;
			var focusedItemIndex = this.state.focusedItemIndex;


			if (focusedItemIndex === undefined) {
				focusedItemIndex = -1;
			}

			while (focusedItemIndex < _react2.default.Children.count(children) - 1) {
				focusedItemIndex++;
				if (this.isFocusableItemIndex(focusedItemIndex)) {
					return focusedItemIndex;
				}
			}
		}

		// `this.list` is also being accessed from `<ScrollableList/>`.

	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props = this.props,
			    disabled = _props.disabled,
			    tabbable = _props.tabbable,
			    value = _props.value,
			    onChange = _props.onChange,
			    onSelectItem = _props.onSelectItem,
			    highlightSelectedItem = _props.highlightSelectedItem,
			    shouldCreateButtons = _props.shouldCreateButtons,
			    className = _props.className,
			    style = _props.style,
			    children = _props.children;
			var focusedItemIndex = this.state.focusedItemIndex;


			return _react2.default.createElement(
				'ul',
				{
					ref: this.storeListNode,
					onKeyDown: this.onKeyDown,
					style: style,
					className: (0, _classnames2.default)(className, 'rrui__list') },
				_react2.default.Children.map(children, function (item, i) {
					if (item.type !== ItemType) {
						throw new Error('Only <List.Item/>s can be placed inside a <List/> (and remove any whitespace).');
					}

					return _react2.default.cloneElement(item, {
						key: i,
						index: i,
						itemRef: _this2.isFocusableItem(item) ? _this2.storeItemRef : undefined,
						focus: _this2.focusItem,
						focused: focusedItemIndex === i,
						disabled: disabled || item.props.disabled,
						tabIndex: tabbable && (focusedItemIndex === undefined ? i === 0 : focusedItemIndex === i) ? 0 : -1,
						shouldCreateButton: shouldCreateButtons,
						onSelectItem: onChange || onSelectItem,
						selectedItemValue: value,
						highlightSelectedItem: (onChange || onSelectItem) && highlightSelectedItem
					});
				})
			);
		}
	}], [{
		key: 'getDerivedStateFromProps',
		value: function getDerivedStateFromProps(props, state) {
			var newState = {
				items: props.items

				// If `items` property is supplied
				// then it's used to detect "on items changed" event.
			};if (state.items && state.items !== props.items) {
				newState.items = props.items;

				// Focus the first item.
				if (props.focusFirstItemWhenItemsChange) {
					newState.focusedItemValue = props.items[0].value;
					newState.focusedItemIndex = 0;
				}
			}

			if (state.selectedItemValue !== props.value) {
				newState.selectedItemValue = props.value;

				newState.focusedItemValue = props.value;
				newState.focusedItemIndex = props.value === undefined ? undefined : findItemIndexByValue(props.value, props.children);
			}

			return newState;
		}

		// `ref`s of all items currently rendered.


		// Focuses on the list.

	}]);

	return List;
}(PureComponent), _class2.propTypes = {
	value: _propTypes2.default.any,
	onChange: _propTypes2.default.func,

	// If `items` property is supplied then it's used to
	// detect "on items changed" event in `getDerivedStateFromProps`.
	// It seems to be the only usage of the `items` property.
	items: _propTypes2.default.arrayOf(_propTypes2.default.object),

	// Legacy method, use `onChange` instead.
	onSelectItem: _propTypes2.default.func,
	highlightSelectedItem: _propTypes2.default.bool.isRequired,

	onFocusItem: _propTypes2.default.func,
	onKeyDown: _propTypes2.default.func,

	tabbable: _propTypes2.default.bool.isRequired,
	shouldFocus: _propTypes2.default.bool.isRequired,
	focusFirstItemWhenItemsChange: _propTypes2.default.bool.isRequired,
	shouldCreateButtons: _propTypes2.default.bool.isRequired
}, _class2.defaultProps = {
	tabbable: true,
	shouldFocus: true,
	focusFirstItemWhenItemsChange: false,
	shouldCreateButtons: true,
	highlightSelectedItem: true
}, _temp2)) || _class;

exports.default = List;
var Item = exports.Item = (_temp4 = _class3 = function (_React$Component) {
	_inherits(Item, _React$Component);

	function Item() {
		var _ref2;

		var _temp3, _this3, _ret2;

		_classCallCheck(this, Item);

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return _ret2 = (_temp3 = (_this3 = _possibleConstructorReturn(this, (_ref2 = Item.__proto__ || Object.getPrototypeOf(Item)).call.apply(_ref2, [this].concat(args))), _this3), _this3.onMouseDown = function (event) {
			var _this3$props = _this3.props,
			    value = _this3$props.value,
			    index = _this3$props.index,
			    focus = _this3$props.focus,
			    children = _this3$props.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onMouseDown` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onMouseDown` defined on the `<List.Item/>` child element
			// because `onMouseDown` gets overridden for `<List.Item/>` child element.

			var onMouseDown = _this3.shouldCreateButton() ? _this3.props.onMouseDown : children.props.onMouseDown;

			// Without this Safari (both mobile and desktop)
			// won't select any item in an expanded list
			// because it will collapse the list immediately
			// on `mouseDown` due to `blur` event being fired.
			event.preventDefault();

			if (_this3.isSelectable()) {
				focus(index);
			}

			if (onMouseDown) {
				onMouseDown(event);
			}
		}, _this3.onFocus = function (event) {
			var _this3$props2 = _this3.props,
			    value = _this3$props2.value,
			    focus = _this3$props2.focus,
			    index = _this3$props2.index,
			    children = _this3$props2.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onFocus` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onFocus` defined on the `<List.Item/>` child element
			// because `onFocus` gets overridden for `<List.Item/>` child element.

			var onFocus = _this3.shouldCreateButton() ? _this3.props.onFocus : children.props.onFocus;

			if (_this3.isSelectable()) {
				focus(index);
			}

			if (onFocus) {
				onFocus(event);
			}
		}, _this3.onClick = function (event) {
			var _this3$props3 = _this3.props,
			    onClick = _this3$props3.onClick,
			    onSelect = _this3$props3.onSelect,
			    onSelectItem = _this3$props3.onSelectItem,
			    index = _this3$props3.index,
			    value = _this3$props3.value,
			    children = _this3$props3.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onClick` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onClick` defined on the `<List.Item/>` child element
			// because `onClick` gets overridden for `<List.Item/>` child element,
			// and also call `onClick` defined on the `<List.Item/>` (if any).

			if (onClick) {
				onClick(event);
			}

			if (!_this3.shouldCreateButton()) {
				// Since `onClick` gets overridden
				// for `<List.Item/>` child element
				// call its original `onClick` manually here.
				if (children.props.onClick) {
					children.props.onClick(event);
				}
			}

			if (_this3.isSelectable()) {
				if (onSelect) {
					onSelect(value, index);
				}
				if (onSelectItem) {
					onSelectItem(value, index);
				}
			}
		}, _this3.focus = function () {
			var children = _this3.props.children;


			(0, _focus.focus)(_react2.default.Children.toArray(children)[0]);
		}, _this3.storeRef = function (ref) {
			var _this3$props4 = _this3.props,
			    itemRef = _this3$props4.itemRef,
			    index = _this3$props4.index;


			if (itemRef) {
				itemRef(ref, index);
			}
		}, _temp3), _possibleConstructorReturn(_this3, _ret2);
	}

	_createClass(Item, [{
		key: 'isSelectable',
		value: function isSelectable() {
			var children = this.props.children;

			return children.type !== DividerType;
		}
	}, {
		key: 'shouldCreateButton',
		value: function shouldCreateButton() {
			var _props2 = this.props,
			    onClick = _props2.onClick,
			    onSelect = _props2.onSelect,
			    onSelectItem = _props2.onSelectItem,
			    shouldCreateButton = _props2.shouldCreateButton;


			return this.isSelectable() && (onClick || onSelect || onSelectItem && shouldCreateButton);
		}
	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props,
			    value = _props3.value,
			    icon = _props3.icon,
			    focused = _props3.focused,
			    disabled = _props3.disabled,
			    className = _props3.className,
			    tabIndex = _props3.tabIndex,
			    highlightSelectedItem = _props3.highlightSelectedItem,
			    selectedItemValue = _props3.selectedItemValue,
			    children = _props3.children;

			// Throws an error for some weird reason.
			// React.Children.only(children)

			if (_react2.default.Children.count(children) !== 1) {
				throw new Error('Each <List.Item/> must have a single child (and remove any whitespace).');
			}

			var properties = {
				ref: this.storeRef,
				onMouseDown: this.onMouseDown,
				onClick: this.onClick,
				onFocus: this.onFocus,
				className: (0, _classnames2.default)(className, 'rrui__list__item', {
					'rrui__list__item--focused': focused,
					'rrui__list__item--selected': highlightSelectedItem && this.shouldCreateButton() && value === selectedItemValue,
					'rrui__list__item--disabled': disabled,
					'rrui__list__item--divider': children.type === DividerType
				})
			};

			var ItemComponent = void 0;
			var itemChildren = void 0;
			var label = void 0;

			if (this.shouldCreateButton()) {
				ItemComponent = 'button';
				label = this.props.label || children;
				properties.type = 'button';
				properties['aria-label'] = label;
				properties.tabIndex = tabIndex;
				properties.disabled = disabled;
				properties.className = (0, _classnames2.default)(properties.className, 'rrui__button-reset', 'rrui__list__item--button');

				// Replace `itemChildren` array with `<React.Fragment/>`
				// in some future when React >= 16.2.0 is common.
				//
				// <React.Fragment>
				// 	{/* Icon. */}
				// 	{ icon &&
				// 		<div className="rrui__list__item-icon">
				// 			{ React.createElement(icon, { value, label }) }
				// 		</div>
				// 	}
				//
				// 	{/* Label (or content). */}
				// 	{ children }
				// </React.Fragment>

				// Label (or content).
				itemChildren = _react2.default.Children.toArray(children);

				// Icon.
				if (icon) {
					itemChildren.unshift(_react2.default.createElement(
						'div',
						{ key: 'icon', className: 'rrui__list__item-icon' },
						_react2.default.createElement(icon, { value: value, label: label })
					));
				}
			} else {
				// Don't overwrite `className` already defined on the `children`.
				properties.className = (0, _classnames2.default)(properties.className, children.props && children.props.className);
			}

			return _react2.default.createElement(
				'li',
				{ className: 'rrui__list__list-item' },
				ItemComponent && _react2.default.createElement(ItemComponent, properties, itemChildren),
				!ItemComponent && _react2.default.cloneElement(children, properties)
			);
		}
	}]);

	return Item;
}(_react2.default.Component), _class3.propTypes = {
	value: _propTypes2.default.any,
	index: _propTypes2.default.number,
	focused: _propTypes2.default.bool,
	onClick: _propTypes2.default.func,
	// `onSelect` is deprecated, use `onClick` instead.
	onSelect: _propTypes2.default.func,
	onSelectItem: _propTypes2.default.func,
	selectedItemValue: _propTypes2.default.any,
	highlightSelectedItem: _propTypes2.default.bool,
	shouldCreateButton: _propTypes2.default.bool
}, _temp4);


List.Item = Item;

// Workaround for `react-hot-loader`.
// https://github.com/gaearon/react-hot-loader#checking-element-types
var ItemType = _react2.default.createElement(Item, null).type;

function haveItemsChanged(props, prevProps) {
	var items = _react2.default.Children.toArray(props.children);
	var prevItems = _react2.default.Children.toArray(prevProps.children);

	if (items.length !== prevItems.length) {
		return true;
	}

	var i = 0;
	while (i < items.length) {
		if (items[i].props.value !== prevItems[i].props.value) {
			return true;
		}
		i++;
	}

	return false;
}

function findItemIndexByValue(value, children) {
	var items = _react2.default.Children.toArray(children);

	var i = 0;
	for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
		var _ref3;

		if (_isArray) {
			if (_i >= _iterator.length) break;
			_ref3 = _iterator[_i++];
		} else {
			_i = _iterator.next();
			if (_i.done) break;
			_ref3 = _i.value;
		}

		var item = _ref3;

		if (item.props.value === value) {
			return i;
		}
		i++;
	}

	// The item could be missing due to being trimmed by `maxOptions` in `Autocomplete`.
	// console.error(`Item with value ${value} not found in a <List/>. Available values: ${items.length > 0 ? items.map(_ => _.props.value).join(', ') : '(none)'}.`)
}
//# sourceMappingURL=List.js.map