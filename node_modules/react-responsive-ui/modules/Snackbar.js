'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

// Sits at the bottom of a page and displays notifications
var Snackbar = (_temp2 = _class = function (_PureComponent) {
	_inherits(Snackbar, _PureComponent);

	function Snackbar() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Snackbar);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Snackbar.__proto__ || Object.getPrototypeOf(Snackbar)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			values: []
		}, _this.next = function () {
			var values = _this.state.values;
			var _this$props = _this.props,
			    minTime = _this$props.minTime,
			    lengthTimeFactor = _this$props.lengthTimeFactor;

			// Get the next notification from the queue
			// (will be `undefined` if the queue is empty)

			var value = values.shift();

			// Reset the notification display
			_this.setState({ value: value, height: undefined, wide: undefined, hiding: false });

			// If the queue is empty, then just exit
			if (!value) {
				return;
			}

			// `state.show` will be set to `true` later,
			// when the height of the element is measured
			// (which is after it renders)

			if (value.duration === -1) {
				return;
			}

			// The total display duration (in milliseconds) of a snack
			// is `minTime + message.length * lengthTimeFactor`
			var length = typeof value.content === 'string' ? value.content.length : value.length || 0;
			var duration = value.duration || minTime + length * lengthTimeFactor;

			// Hide the notification after it expires
			_this.auto_hide_timer = setTimeout(_this.hide, duration);
		}, _this.hide = function () {
			var hideAnimationDuration = _this.props.hideAnimationDuration;

			// Start the hiding animation for the notification

			_this.setState({ show: false, hiding: true });

			// Display the next notification
			// after the currently being hidden one
			// finishes its hiding animation.
			_this.show_next_snack_timeout = setTimeout(_this.next, hideAnimationDuration);
		}, _this.storeContainerNode = function (node) {
			return _this.container = node;
		}, _this.storeSnackbarNode = function (node) {
			return _this.snackbar = node;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Snackbar, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.auto_hide_timer);
			clearTimeout(this.show_next_snack_timeout);
			clearTimeout(this.show_snack_timeout);
		}
	}, {
		key: 'receiveNewValue',
		value: function receiveNewValue(prevProps) {
			var value = this.props.value;

			// If `value` has changed then push it to the queue.

			if (value && value !== prevProps.value) {
				// Add the notification to the queue
				this.push(value);
			}
		}

		// Adds a notification to the queue

	}, {
		key: 'push',
		value: function push(new_value) {
			var _state = this.state,
			    values = _state.values,
			    value = _state.value;

			// Add the notification to the queue

			values.push(new_value);

			// If the notification queue was empty
			// then kick-start it.
			if (!value) {
				this.next();
			}
		}

		// Displays the next notification in the queue

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps) {
			var _this2 = this;

			var _state2 = this.state,
			    height = _state2.height,
			    value = _state2.value;

			// If `value` got updated then push it to the list of `values`.

			this.receiveNewValue(prevProps);

			// The notification DOM element has just been rendered
			// which means its dimensions are set by now.
			// Calculate the notification container DOM element height
			// so that the slide-from-bottom animation knows
			// its target Y-position for the CSS `translate` transform.
			if (height === undefined && value) {
				height = this.snackbar.offsetHeight;
				var wide = this.snackbar.offsetWidth === document.documentElement.clientWidth;
				var marginBottom = parseInt(getComputedStyle(this.container).marginBottom);
				var anti_lag_timeout = 100; // Otherwise it would jump to fully shown in Chrome when there's a queue of snacks waiting to be shown
				this.setState({ height: height, wide: wide, marginBottom: marginBottom }, function () {
					_this2.show_snack_timeout = setTimeout(function () {
						return _this2.setState({ show: true });
					}, anti_lag_timeout);
				});
			}
		}
	}, {
		key: 'renderContent',
		value: function renderContent(value) {
			if (value.component) {
				return value.component(_extends({}, value.props, { hide: this.hide }));
			}
			return null;
		}
	}, {
		key: 'render',
		value: function render() {
			var type = this.props.type;
			var _state3 = this.state,
			    show = _state3.show,
			    value = _state3.value,
			    height = _state3.height,
			    wide = _state3.wide,
			    marginBottom = _state3.marginBottom,
			    hiding = _state3.hiding;


			var container_style = {};

			if (!show) {
				// If no snack is being shown,
				// or if a snack is about to be shown,
				// then shift it under the screen's bottom border
				// to show the slide-from-bottom animation at the next step.
				if (height !== undefined) {
					container_style.transform = 'translateY(' + (height + marginBottom) + 'px)';
				}

				if (!hiding) {
					container_style.transition = 'none';
				}
			}

			return _react2.default.createElement(
				'div',
				{
					ref: this.storeContainerNode,
					style: container_style,
					className: (0, _classnames2.default)('rrui__snackbar__container', {
						'rrui__snackbar__container--hidden': !show,
						'rrui__snackbar__container--wide': wide
					}) },
				_react2.default.createElement(
					'div',
					{
						ref: this.storeSnackbarNode,
						className: (0, _classnames2.default)('rrui__snackbar', value && value.type && 'rrui__snackbar--' + value.type) },
					_react2.default.createElement(
						'div',
						{
							className: 'rrui__snackbar__text' },
						value && (value.content !== undefined ? value.content : this.renderContent(value))
					)
				)
			);
		}
	}]);

	return Snackbar;
}(PureComponent), _class.propTypes = {
	// Snackbar value (either a message, or an object)
	value: _propTypes2.default.shape({
		// Notification content.
		content: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]),

		// Instead of `content` property one may supply `component` property
		// which must be a React component which receives all "rest" `value` properties
		// and also `hide`property (a function that hides the notification).
		component: _propTypes2.default.func,

		// `props` are passed to `component`.
		props: _propTypes2.default.object,

		// If `content` is a `string` then its `length` is calculated automatically.
		// Otherwise one may pass `length` manually.
		// It's used for calculating notification `duration`.
		length: _propTypes2.default.number,

		// `type` is appended as a BEM modifier to `.rrui__snackbar` CSS class.
		// E.g. `.rrui__snackbar--error` for `{ type: "error" }`.
		type: _propTypes2.default.string,

		// How long does the notification stay.
		// Pass `-1` for it to stay until it's closed manually.
		duration: _propTypes2.default.number
	}),

	// // "Snack" showing CSS animation duration.
	// // Is 225 milliseconds by default.
	// showAnimationDuration : PropTypes.number.isRequired,

	// "Snack" hiding CSS animation duration.
	// Is 195 milliseconds by default.
	hideAnimationDuration: _propTypes2.default.number.isRequired,

	// The total display duration (in milliseconds) of a snack
	// is `minTime + message.length * lengthTimeFactor`
	minTime: _propTypes2.default.number.isRequired,
	lengthTimeFactor: _propTypes2.default.number.isRequired
}, _class.defaultProps = {
	// showAnimationDuration : 225,
	hideAnimationDuration: 195,
	minTime: 1200,
	lengthTimeFactor: 60
}, _temp2);
exports.default = Snackbar;
//# sourceMappingURL=Snackbar.js.map