{"version":3,"sources":["../source/format.js"],"names":["format","value","caret","formatter","text","template","undefined","length","index","found","possibly_last_input_character_index"],"mappings":";;;;;kBAkCwBA,M;;AAlCxB;;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,MAAT,CAAgBC,KAAhB,EAAuBC,KAAvB,EAA8BC,SAA9B,EACf;AACC,KAAI,OAAOA,SAAP,KAAqB,QAAzB,EACA;AACCA,cAAY,iCAAmBA,SAAnB,CAAZ;AACA;;AAJF,YAM0BA,UAAUF,KAAV,KAAoB,EAN9C;AAAA,KAMOG,IANP,QAMOA,IANP;AAAA,KAMaC,QANb,QAMaA,QANb;;AAQC,KAAID,SAASE,SAAb,EACA;AACEF,SAAOH,KAAP;AACD;;AAED,KAAII,QAAJ,EACA;AACC,MAAIH,UAAUI,SAAd,EACA;AACCJ,WAAQE,KAAKG,MAAb;AACA,GAHD,MAKA;AACC,OAAIC,QAAQ,CAAZ;AACA,OAAIC,QAAQ,KAAZ;;AAEA,OAAIC,sCAAsC,CAAC,CAA3C;;AAEA,UAAOF,QAAQJ,KAAKG,MAAb,IAAuBC,QAAQH,SAASE,MAA/C,EACA;AACC;AACA,QAAIH,KAAKI,KAAL,MAAgBH,SAASG,KAAT,CAApB,EACA;AACC,SAAIN,UAAU,CAAd,EACA;AACCO,cAAQ,IAAR;AACAP,cAAQM,KAAR;AACA;AACA;;AAEDE,2CAAsCF,KAAtC;;AAEAN;AACA;;AAEDM;AACA;;AAED;AACA;AACA,OAAI,CAACC,KAAL,EACA;AACCP,YAAQQ,sCAAsC,CAA9C;AACA;AACD;AACD;;AAED,QAAO,EAAEN,UAAF,EAAQF,YAAR,EAAP;AACA","file":"format.js","sourcesContent":["import template_formatter from './template formatter'\r\n\r\n// Formats `value` value preserving `caret` at the same character.\r\n//\r\n// `{ value, caret }` attribute is the result of `parse()` function call.\r\n//\r\n// Returns `{ text, caret }` where the new `caret` is the caret position\r\n// inside `text` text corresponding to the original `caret` position inside `value`.\r\n//\r\n// `formatter(value)` is a function returning `{ text, template }`.\r\n//\r\n// `text` is the `value` value formatted using `template`.\r\n// It may either cut off the non-filled right part of the `template`\r\n// or it may fill the non-filled character placeholders\r\n// in the right part of the `template` with `spacer`\r\n// which is a space (' ') character by default.\r\n//\r\n// `template` is the template used to format the `value`.\r\n// It can be either a full-length template or a partial template.\r\n//\r\n// `formatter` can also be a string â€” a `template`\r\n// where character placeholders are denoted by 'x'es.\r\n// In this case `formatter` function is automatically created.\r\n//\r\n// Example:\r\n//\r\n// `value` is '880',\r\n// `caret` is `2` (before the first `0`)\r\n//\r\n// `formatter` is `'880' =>\r\n//   { text: '8 (80 )', template: 'x (xxx) xxx-xx-xx' }`\r\n//\r\n// The result is `{ text: '8 (80 )', caret: 4 }`.\r\n//\r\nexport default function format(value, caret, formatter)\r\n{\r\n\tif (typeof formatter === 'string')\r\n\t{\r\n\t\tformatter = template_formatter(formatter)\r\n\t}\r\n\r\n\tlet { text, template } = formatter(value) || {}\r\n\r\n\tif (text === undefined)\r\n\t{\r\n\t\t text = value\r\n\t}\r\n\r\n\tif (template)\r\n\t{\r\n\t\tif (caret === undefined)\r\n\t\t{\r\n\t\t\tcaret = text.length\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet index = 0\r\n\t\t\tlet found = false\r\n\r\n\t\t\tlet possibly_last_input_character_index = -1\r\n\r\n\t\t\twhile (index < text.length && index < template.length)\r\n\t\t\t{\r\n\t\t\t\t// Character placeholder found\r\n\t\t\t\tif (text[index] !== template[index])\r\n\t\t\t\t{\r\n\t\t\t\t\tif (caret === 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = true\r\n\t\t\t\t\t\tcaret = index\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpossibly_last_input_character_index = index\r\n\r\n\t\t\t\t\tcaret--\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex++\r\n\t\t\t}\r\n\r\n\t\t\t// If the caret was positioned after last input character,\r\n\t\t\t// then the text caret index is just after the last input character.\r\n\t\t\tif (!found)\r\n\t\t\t{\r\n\t\t\t\tcaret = possibly_last_input_character_index + 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn { text, caret }\r\n}"]}