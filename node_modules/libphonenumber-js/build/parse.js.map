{"version":3,"sources":["../source/parse.js"],"names":["parse","is_viable_phone_number","extract_formatted_phone_number","strip_national_prefix_and_carrier_code","find_country_code","MIN_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","default_options","country","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","text","options","metadata","defaultCountry","hasCountry","v2","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","nationalNumber","national_number","countryCallingCode","carrierCode","selectedCountry","length","phoneNumber","valid","nationalNumberPattern","extended","result","possible","possibleLengths","undefined","phone","test","starts_at","search","slice","replace","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","TypeError","strip_extension","start","number_without_extension","matches","match","i","indexOf","with_extension_stripped","default_country","chooseCountryByCountryCallingCode","parse_national_number","carrier_code","exactCountry","potential_national_number"],"mappings":"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","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of 17th November, 2016.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport\r\n{\r\n\textractCountryCallingCode,\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS,\r\n\tMAX_LENGTH_FOR_NSN,\r\n\tmatches_entirely,\r\n\tcreate_extension_pattern\r\n}\r\nfrom './common'\r\n\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport getCountryCallingCode from './getCountryCallingCode'\r\n\r\nimport get_number_type, { check_number_length_for_type } from './getNumberType'\r\n\r\nimport { is_possible_number } from './isPossibleNumber'\r\n\r\nimport { parseRFC3966 } from './RFC3966'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\n// The minimum length of the national significant number.\r\nconst MIN_LENGTH_FOR_NSN = 2\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\r\n\r\n//  Regular expression of viable phone numbers. This is location independent.\r\n//  Checks we have at least three leading digits, and only valid punctuation,\r\n//  alpha characters and digits in the phone number. Does not include extension\r\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\r\n//  used as a placeholder for carrier codes, for example in Brazilian phone\r\n//  numbers. We also allow multiple '+' characters at the start.\r\n//\r\n//  Corresponds to the following:\r\n//  [digits]{minLengthNsn}|\r\n//  plus_sign*\r\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\r\n//\r\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\r\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\r\n//  The second expression restricts the number of digits to three or more, but\r\n//  then allows them to be in international form, and to have alpha-characters\r\n//  and punctuation. We split up the two reg-exes here and combine them when\r\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\r\n//  with ^ and append $ to each branch.\r\n//\r\n//  \"Note VALID_PUNCTUATION starts with a -,\r\n//   so must be the first in the range\" (c) Google devs.\r\n//  (wtf did they mean by saying that; probably nothing)\r\n//\r\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\r\n//\r\n// And this is the second reg-exp:\r\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\r\n//\r\nconst VALID_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'(?:' +\r\n\t\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t\t'[' + VALID_DIGITS + ']' +\r\n\t'){3,}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\n// The combined regular expression for valid phone numbers:\r\n//\r\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\r\n(\r\n\t// Either a short two-digit-only phone number\r\n\t'^' +\r\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\r\n\t'$' +\r\n\t'|' +\r\n\t// Or a longer fully parsed phone number (min 3 characters)\r\n\t'^' +\r\n\t\tVALID_PHONE_NUMBER +\r\n\t\t// Phone number extensions\r\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\r\n\t'$'\r\n,\r\n'i')\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\r\n\r\nconst default_options =\r\n{\r\n\tcountry: {}\r\n}\r\n\r\n// `options`:\r\n//  {\r\n//    country:\r\n//    {\r\n//      restrict - (a two-letter country code)\r\n//                 the phone number must be in this country\r\n//\r\n//      default - (a two-letter country code)\r\n//                default country to use for phone number parsing and validation\r\n//                (if no country code could be derived from the phone number)\r\n//    }\r\n//  }\r\n//\r\n// Returns `{ country, number }`\r\n//\r\n// Example use cases:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\nexport default function parse(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new Error('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formatted_phone_number, ext } = parse_input(text, options.v2)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formatted_phone_number)\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new Error('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst\r\n\t{\r\n\t\tcountry,\r\n\t\tnational_number : nationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode\r\n\t}\r\n\t= parse_phone_number\r\n\t(\r\n\t\tformatted_phone_number,\r\n\t\toptions.defaultCountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.selectedCountry())\r\n\t{\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new Error('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new Error('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new Error('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2)\r\n\t{\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = country && matches_entirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\r\n\r\n\tif (!options.extended)\r\n\t{\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\r\n\t\tphone : nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n// Checks to see if the string of characters could possibly be a phone number at\r\n// all. At the moment, checks to see that the string begins with at least 2\r\n// digits, ignoring any punctuation commonly found in phone numbers. This method\r\n// does not require the number to be normalized in advance - but does assume\r\n// that leading non-number symbols have been removed, such as by the method\r\n// `extract_possible_number`.\r\n//\r\nexport function is_viable_phone_number(number)\r\n{\r\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\r\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\r\n}\r\n\r\n/**\r\n * Extracts a parseable phone number.\r\n * @param  {string} text - Input.\r\n * @return {string}.\r\n */\r\nexport function extract_formatted_phone_number(text, v2)\r\n{\r\n\tif (!text)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH)\r\n\t{\r\n\t\tif (v2) {\r\n\t\t\tthrow new Error('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\t// Attempt to extract a possible number from the string passed in\r\n\r\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\r\n\r\n\tif (starts_at < 0)\r\n\t{\r\n\t\treturn\r\n\t}\r\n\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(starts_at)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n// Strips any national prefix (such as 0, 1) present in the number provided.\r\n// \"Carrier codes\" are only used  in Colombia and Brazil,\r\n// and only when dialing within those countries from a mobile phone to a fixed line number.\r\nexport function strip_national_prefix_and_carrier_code(number, metadata)\r\n{\r\n\tif (!number || !metadata.nationalPrefixForParsing())\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\t// Attempt to parse the first digits as a national prefix\r\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\r\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\r\n\r\n\t// If no national prefix is present in the phone number,\r\n\t// but the national prefix is optional for this country,\r\n\t// then consider this phone number valid.\r\n\t//\r\n\t// Google's reference `libphonenumber` implementation\r\n\t// wouldn't recognize such phone numbers as valid,\r\n\t// but I think it would perfectly make sense\r\n\t// to consider such phone numbers as valid\r\n\t// because if a national phone number was originally\r\n\t// formatted without the national prefix\r\n\t// then it must be parseable back into the original national number.\r\n\t// In other words, `parse(format(number))`\r\n\t// must always be equal to `number`.\r\n\t//\r\n\tif (!national_prefix_matcher)\r\n\t{\r\n\t\treturn { number }\r\n\t}\r\n\r\n\tlet national_significant_number\r\n\r\n\t// `national_prefix_for_parsing` capturing groups\r\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\r\n\tconst captured_groups_count = national_prefix_matcher.length - 1\r\n\r\n\t// If the national number tranformation is needed then do it.\r\n\t//\r\n\t// `national_prefix_matcher[captured_groups_count]` means that\r\n\t// the corresponding captured group is not empty.\r\n\t// It can be empty if it's optional.\r\n\t// Example: \"0?(?:...)?\" for Argentina.\r\n\t//\r\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\r\n\t{\r\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\r\n\t}\r\n\t// Else, no transformation is necessary,\r\n\t// and just strip the national prefix.\r\n\telse\r\n\t{\r\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\r\n\t}\r\n\r\n\tlet carrierCode\r\n\tif (captured_groups_count > 0)\r\n\t{\r\n\t\tcarrierCode = national_prefix_matcher[1]\r\n\t}\r\n\r\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\r\n\t//\r\n\t// // Verify the parsed national (significant) number for this country\r\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\r\n\t// //\r\n\t// // If the original number (before stripping national prefix) was viable,\r\n\t// // and the resultant number is not, then prefer the original phone number.\r\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\r\n\t// // a national prefix and a leading digit of a valid national phone number,\r\n\t// // like `8` is the national prefix for Russia and both\r\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t// if (matches_entirely(number, national_number_rule) &&\r\n\t// \t\t!matches_entirely(national_significant_number, national_number_rule))\r\n\t// {\r\n\t// \treturn number\r\n\t// }\r\n\r\n\t// Return the parsed national (significant) number\r\n   return {\r\n   \tnumber: national_significant_number,\r\n   \tcarrierCode\r\n   }\r\n}\r\n\r\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\r\n{\r\n\t// Is always non-empty, because `country_calling_code` is always valid\r\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\r\n\r\n\t// If there's just one country corresponding to the country code,\r\n\t// then just return it, without further phone number digits validation.\r\n\tif (possible_countries.length === 1)\r\n\t{\r\n\t\treturn possible_countries[0]\r\n\t}\r\n\r\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\r\n}\r\n\r\n// Changes `metadata` `country`.\r\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\r\n{\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\tfor (const country of possible_countries)\r\n\t{\r\n\t\tmetadata.country(country)\r\n\r\n\t\t// Leading digits check would be the simplest one\r\n\t\tif (metadata.leadingDigits())\r\n\t\t{\r\n\t\t\tif (national_phone_number &&\r\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\r\n\t\t\t{\r\n\t\t\t\treturn country\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Else perform full validation with all of those\r\n\t\t// fixed-line/mobile/etc regular expressions.\r\n\t\telse if (get_number_type({ phone: national_phone_number, country }, metadata.metadata))\r\n\t\t{\r\n\t\t\treturn country\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Sort out arguments\r\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\r\n{\r\n\tlet text\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `parse('88005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\ttext = arg_1\r\n\t}\r\n\telse throw new TypeError('A phone number for parsing must be a string.')\r\n\r\n\t// If \"default country\" argument is being passed\r\n\t// then move it to `options`.\r\n\t// `parse('88005553535', 'RU', [options], metadata)`.\r\n\tif (typeof arg_2 !== 'object')\r\n\t{\r\n\t\tif (arg_4)\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\r\n\t\t\tmetadata = arg_4\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = { defaultCountry: arg_2 }\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t}\r\n\t// No \"default country\" argument is being passed.\r\n\t// International phone number is passed.\r\n\t// `parse('+78005553535', [options], metadata)`.\r\n\telse\r\n\t{\r\n\t\tif (arg_3)\r\n\t\t{\r\n\t\t\toptions  = arg_2\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_2\r\n\t\t}\r\n\t}\r\n\r\n\t// Apply default options.\r\n\tif (options)\r\n\t{\r\n\t\toptions = { ...default_options, ...options }\r\n\t}\r\n\telse\r\n\t{\r\n\t\toptions = default_options\r\n\t}\r\n\r\n\treturn { text, options, metadata: new Metadata(metadata) }\r\n}\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nfunction strip_extension(number)\r\n{\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0)\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst number_without_extension = number.slice(0, start)\r\n\t/* istanbul ignore if - seems a bit of a redundant check */\r\n\tif (!is_viable_phone_number(number_without_extension))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length)\r\n\t{\r\n\t\tif (matches[i] != null && matches[i].length > 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tnumber : number_without_extension,\r\n\t\t\t\text    : matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parse_input(text, v2)\r\n{\r\n\t// Parse RFC 3966 phone number URI.\r\n\tif (text && text.indexOf('tel:') === 0)\r\n\t{\r\n\t\treturn parseRFC3966(text)\r\n\t}\r\n\r\n\tlet number = extract_formatted_phone_number(text, v2)\r\n\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number || !is_viable_phone_number(number))\r\n\t{\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst with_extension_stripped = strip_extension(number)\r\n\tif (with_extension_stripped.ext)\r\n\t{\r\n\t\treturn with_extension_stripped\r\n\t}\r\n\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, national_number, ext)\r\n{\r\n\tconst result =\r\n\t{\r\n\t\tcountry,\r\n\t\tphone : national_number\r\n\t}\r\n\r\n\tif (ext)\r\n\t{\r\n\t\tresult.ext = ext\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * Returns `{ country, countryCallingCode, national_number }`.\r\n */\r\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\r\n{\r\n\tlet { countryCallingCode, number } = extractCountryCallingCode(formatted_phone_number, default_country, metadata.metadata)\r\n\r\n\tif (!number) {\r\n\t\treturn { countryCallingCode }\r\n\t}\r\n\r\n\tlet country\r\n\r\n\tif (countryCallingCode)\r\n\t{\r\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t}\r\n\telse if (default_country)\r\n\t{\r\n\t\tmetadata.country(default_country)\r\n\t\tcountry = default_country\r\n\t\tcountryCallingCode = getCountryCallingCode(default_country, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tconst { national_number, carrier_code } = parse_national_number(number, metadata)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = find_country_code(countryCallingCode, national_number, metadata)\r\n\tif (exactCountry)\r\n\t{\r\n\t\tcountry = exactCountry\r\n\t\tmetadata.country(country)\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tnational_number,\r\n\t\tcarrierCode: carrier_code\r\n\t}\r\n}\r\n\r\nfunction parse_national_number(number, metadata)\r\n{\r\n\tlet national_number = parseIncompletePhoneNumber(number)\r\n\tlet carrier_code\r\n\r\n\t// Only strip national prefixes for non-international phone numbers\r\n\t// because national prefixes can't be present in international phone numbers.\r\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\r\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\r\n\t// and then it would assume that's a valid number which it isn't.\r\n\t// So no forgiveness for grandmas here.\r\n\t// The issue asking for this fix:\r\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\r\n\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(national_number, metadata)\r\n\r\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\r\n\tif (metadata.possibleLengths())\r\n\t{\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tswitch (check_number_length_for_type(potential_national_number, undefined, metadata))\r\n\t\t{\r\n\t\t\tcase 'TOO_SHORT':\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\tcase 'INVALID_LENGTH':\r\n\t\t\t\tbreak\r\n\t\t\tdefault:\r\n\t\t\t\tnational_number = potential_national_number\r\n\t\t\t\tcarrier_code = carrierCode\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t// like `8` is the national prefix for Russia and both\r\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\tif (matches_entirely(national_number, metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matches_entirely(potential_national_number, metadata.nationalNumberPattern()))\r\n\t\t{\r\n\t\t\t// Keep the number without stripping national prefix.\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnational_number = potential_national_number\r\n\t\t\tcarrier_code = carrierCode\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tnational_number,\r\n\t\tcarrier_code\r\n\t}\r\n}\r\n\r\n// Determines the country for a given (possibly incomplete) phone number.\r\n// export function get_country_from_phone_number(number, metadata)\r\n// {\r\n// \treturn parse_phone_number(number, null, metadata).country\r\n// }"]}