'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

// import { isInternetExplorer } from './utility/dom'


var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _scrollIntoViewIfNeeded = require('scroll-into-view-if-needed');

var _scrollIntoViewIfNeeded2 = _interopRequireDefault(_scrollIntoViewIfNeeded);

var _Close = require('./Close');

var _Close2 = _interopRequireDefault(_Close);

var _focus = require('./utility/focus');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

/**
 * Usage:
 *
 * <button onClick={() => this.expandable.toggle()}>
 *   Toggle
 * </button>
 *
 * <Expandable ref={ref => this.expandable = ref}>
 *   ...
 * </Expandable>
 *
 * Methods:
 * * `.toggle()`
 * * `.expand()`
 * * `.collapse()`
 * * `.isExpanded()`
 */
var Expandable = (_temp2 = _class = function (_PureComponent) {
	_inherits(Expandable, _PureComponent);

	function Expandable() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Expandable);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Expandable.__proto__ || Object.getPrototypeOf(Expandable)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.onTap = function (event) {
			var _this$props = _this.props,
			    getTogglerNode = _this$props.getTogglerNode,
			    onTapOutside = _this$props.onTapOutside;


			if (_this.container.contains(event.target)) {
				return;
			}

			if (getTogglerNode) {
				if (getTogglerNode().contains(event.target)) {
					return;
				}
			}

			if (onTapOutside) {
				onTapOutside();
			}
		}, _this.onTouchStart = function (event) {
			// Ignore multitouch.
			if (event.touches.length > 1) {
				// Reset.
				return _this.onTouchCancel();
			}

			_this.initialTouchX = event.changedTouches[0].clientX;
			_this.initialTouchY = event.changedTouches[0].clientY;
			_this.tapping = true;
		}, _this.onTouchMove = function (event) {
			// Ignore multitouch.
			if (!_this.tapping) {
				return;
			}

			var deltaX = Math.abs(event.changedTouches[0].clientX - _this.initialTouchX);
			var deltaY = Math.abs(event.changedTouches[0].clientY - _this.initialTouchY);
			var moveThreshold = 5;

			if (deltaX > moveThreshold || deltaY > moveThreshold) {
				// Reset.
				_this.onTouchCancel();
			}
		}, _this.onTouchEnd = function (event) {
			// Ignore multitouch.
			if (!_this.tapping) {
				return;
			}

			// Reset.
			_this.onTouchCancel();

			_this.onTap(event);
		}, _this.onTouchCancel = function () {
			_this.initialTouchX = undefined;
			_this.initialTouchY = undefined;
			_this.tapping = false;
		}, _this.isExpanded = function () {
			return _this.state.expanded;
		}, _this.expand = function (parameters) {
			return _this.toggle(true, parameters);
		}, _this.collapse = function () {
			return _this.toggle(false);
		}, _this.toggle = function (expand) {
			var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			var _this$props2 = _this.props,
			    onExpand = _this$props2.onExpand,
			    onExpanded = _this$props2.onExpanded,
			    onCollapse = _this$props2.onCollapse,
			    onCollapsed = _this$props2.onCollapsed,
			    preload = _this$props2.preload,
			    onPreloadStateChange = _this$props2.onPreloadStateChange,
			    onPreloadError = _this$props2.onPreloadError,
			    onTapOutside = _this$props2.onTapOutside;
			var _this$state = _this.state,
			    expanded = _this$state.expanded,
			    isPreloading = _this$state.isPreloading;

			// If no `expand` argument provided then just toggle.

			if (expand === undefined) {
				expand = !expanded;
			}

			// Don't collapse if already collapsed.
			// Don't expand if already expanded
			// until manually forcing a refresh of content.

			var refreshingExpanded = void 0;

			if (expand && expanded && parameters.refresh) {
				refreshingExpanded = true;
			}

			if (expand === expanded && !refreshingExpanded) {
				return Promise.resolve();
			}

			if (_this.isToggling && !refreshingExpanded) {
				return Promise.resolve();
			}

			_this.isToggling = true;

			// Collapse.
			if (!expand) {
				_this.stopListeningToTouches();

				clearTimeout(_this.scrollIntoViewTimer);

				if (onCollapse) {
					onCollapse({ focusOut: _this.focusOut });
				}

				// Set `expanded` to `false` to play the collapse CSS animation.
				// Once that animation is finished remove
				// the contents of the `<Expanded/>` from DOM.
				return _this.setState({ expanded: false }, function () {
					if (onCollapsed) {
						onCollapsed();
					}

					_this.removeFromDOMAfterCollapsed();

					_this.isToggling = false;
				});
			}

			// Expand.
			return _this.preload().then(function () {
				return new Promise(function (resolve) {
					clearTimeout(_this.removeFromDOMTimer);

					_this.setState({
						shouldRender: true
					},
					// Without the 10ms delay for some reason the CSS "expand" animation won't play.
					// Perhaps a browser decides to optimize two subsequent renders
					// and doesn't render "pre-expanded" and "expanded" states separately.
					// Even with a 0ms delay it would randomly play/not-play the expand animation.
					function () {
						if (onExpand) {
							onExpand();
						}

						setTimeout(function () {
							_this.setState({ expanded: true }, function () {
								if (onExpanded) {
									onExpanded();
								}

								_this.scrollIntoView();
								resolve();

								if (onTapOutside) {
									_this.listenToTouches();
								}

								_this.isToggling = false;
							});
						}, 10);
					});
				});
			});
		}, _this.removeFromDOMAfterCollapsed = function () {
			var expandAnimationDuration = _this.props.expandAnimationDuration;

			// For some reason in IE 11 "scroll into view" scrolls
			// to the top of the page, therefore turn it off for IE.

			_this.removeFromDOMTimer = setTimeout(function () {
				// Re-render to remove the options DOM nodes.
				_this.setState({ shouldRender: false });
			}, expandAnimationDuration * 1.1);
		}, _this.onKeyDown = function (event) {
			if (event.defaultPrevented) {
				return;
			}

			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			switch (event.keyCode) {
				// Collapse on "Escape".
				case 27:
					event.preventDefault();
					// Collapse the list if it's expanded
					return _this.collapse();
			}
		}, _this.storeContainerNode = function (node) {
			return _this.container = node;
		}, _this.onFocusOut = function (event) {
			var onFocusOut = _this.props.onFocusOut;


			_this.focusOut = true;
			onFocusOut(event);
			_this.focusOut = undefined;
		}, _this.onBlur = function (event) {
			var _this$props3 = _this.props,
			    getTogglerNode = _this$props3.getTogglerNode,
			    onFocusOut = _this$props3.onFocusOut;


			if (onFocusOut && _this.container) {
				clearTimeout(_this.blurTimer);
				var result = (0, _focus.onBlur)(event, _this.onFocusOut, function () {
					return _this.container;
				}, getTogglerNode);
				if (typeof result === 'number') {
					_this.blurTimer = result;
				}
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Expandable, [{
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.scrollIntoViewTimer);
			clearTimeout(this.removeFromDOMTimer);
			clearTimeout(this.blurTimer);

			this.stopListeningToTouches();
		}
	}, {
		key: 'listenToTouches',
		value: function listenToTouches() {
			document.addEventListener('touchstart', this.onTouchStart);
			document.addEventListener('touchmove', this.onTouchMove);
			document.addEventListener('touchend', this.onTouchEnd);
			document.addEventListener('touchcancel', this.onTouchCancel);
		}
	}, {
		key: 'stopListeningToTouches',
		value: function stopListeningToTouches() {
			document.removeEventListener('touchstart', this.onTouchStart);
			document.removeEventListener('touchmove', this.onTouchMove);
			document.removeEventListener('touchend', this.onTouchEnd);
			document.removeEventListener('touchcancel', this.onTouchCancel);
		}

		// On mobile devices "blur" event isn't triggered
		// when a user taps outside. This is to allow touch scrolling
		// while not losing focus on an input field or a button.
		// Adding a manual "on click" listener to emulate
		// "on blur" event when user taps outside (to collapse the expandable).

	}, {
		key: 'preload',


		// Preload `<Expanded/>` content (if required).
		value: function preload() {
			var _this2 = this;

			var _props = this.props,
			    preload = _props.preload,
			    onPreloadStateChange = _props.onPreloadStateChange;


			if (preload) {
				this.setState({
					isPreloading: true
				});

				if (onPreloadStateChange) {
					onPreloadStateChange(true);
				}
			}

			return (preload ? preload() : Promise.resolve()).then(function () {
				if (onPreloadStateChange) {
					onPreloadStateChange(false);
				}

				_this2.setState({
					isPreloading: false
				});
			}, function (error) {
				console.error(error);

				// if (onPreloadError) {
				// 	onPreloadError(error)
				// }

				if (onPreloadStateChange) {
					onPreloadStateChange(false);
				}

				_this2.setState({
					isPreloading: false
				});
			});
		}
	}, {
		key: 'scrollIntoView',
		value: function scrollIntoView() {
			var _this3 = this;

			var _props2 = this.props,
			    shouldScrollIntoView = _props2.scrollIntoView,
			    scrollIntoViewDelay = _props2.scrollIntoViewDelay,
			    expandAnimationDuration = _props2.expandAnimationDuration;

			// // For some reason in IE 11 "scroll into view" scrolls
			// // to the top of the page, therefore turn it off for IE.
			// if (!isInternetExplorer() && shouldScrollIntoView)

			if (shouldScrollIntoView) {
				this.scrollIntoViewTimer = setTimeout(function () {
					var expanded = _this3.state.expanded;

					// If still expanded and there are any options
					// then scroll into view.

					if (expanded) {
						// https://github.com/stipsan/scroll-into-view-if-needed/issues/359
						// scrollIntoView(this.container, false, { duration: 300 })

						(0, _scrollIntoViewIfNeeded2.default)(_this3.container, {
							scrollMode: 'if-needed',
							behavior: 'smooth',
							block: 'nearest',
							inline: 'nearest'
						});
					}
				}, Math.max(scrollIntoViewDelay, expandAnimationDuration) * 1.1);
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props,
			    alignment = _props3.alignment,
			    upward = _props3.upward,
			    closeLabel = _props3.closeLabel,
			    CloseButtonIcon = _props3.closeButtonIcon,
			    style = _props3.style,
			    className = _props3.className,
			    children = _props3.children;
			var _state = this.state,
			    shouldRender = _state.shouldRender,
			    expanded = _state.expanded;


			if (!shouldRender) {
				return null;
			}

			// `tabIndex={ -1 }` makes the `<div/>` focusable.
			// Hence the `<Expandable/>` doesn't collapse on click inside it.

			return _react2.default.createElement(
				'div',
				{
					ref: this.storeContainerNode,
					onKeyDown: this.onKeyDown,
					onBlur: this.onBlur,
					tabIndex: -1,
					style: style,
					className: (0, _classnames2.default)(className, 'rrui__expandable', 'rrui__expandable--overlay', 'rrui__shadow', {
						'rrui__expandable--expanded': expanded,
						'rrui__expandable--left-aligned': alignment === 'left',
						'rrui__expandable--right-aligned': alignment === 'right',
						'rrui__expandable--upward': upward,
						'rrui__expandable--downward': !upward
					}) },
				_react2.default.Children.map(children, function (child) {
					return _react2.default.cloneElement(child, {
						className: (0, _classnames2.default)(child.props.className, 'rrui__expandable__content', {
							'rrui__expandable__content--expanded': expanded
						})
					});
				}),
				expanded && CloseButtonIcon && _react2.default.createElement(
					_Close2.default,
					{
						onClick: this.collapse,
						closeLabel: closeLabel,
						className: (0, _classnames2.default)('rrui__close--bottom-right', 'rrui__expandable__close') },
					_react2.default.createElement(CloseButtonIcon, null)
				)
			);
		}
	}]);

	return Expandable;
}(PureComponent), _class.propTypes = {
	// Can optionally preload `<Expandable/>` contents before expanding it.
	// Must return a `Promise`.
	preload: _propTypes2.default.func,
	onPreloadStateChange: _propTypes2.default.func,
	onPreloadError: _propTypes2.default.func,

	onExpand: _propTypes2.default.func,
	onCollapse: _propTypes2.default.func,

	// Whether the `<Expandable/>` expands upwards or downwards.
	alignment: _propTypes2.default.oneOf(['left', 'right']),

	// If this flag is set to `true`,
	// then the dropdown expands itself upward.
	// (as opposed to the default downward)
	upward: _propTypes2.default.bool,

	// CSS style object.
	style: _propTypes2.default.object,

	// CSS class.
	className: _propTypes2.default.string,

	// When the `<Expandable/>` is expanded
	// its content may not fit on the screen.
	// If `scrollIntoView` is `true` (which is the default)
	// then the browser will automatically scroll
	// so that the expanded content fits on the screen.
	scrollIntoView: _propTypes2.default.bool.isRequired,

	// If `scrollIntoView` is `true` (which is the default)
	// then these two are gonna define the delay after which it scrolls into view.
	expandAnimationDuration: _propTypes2.default.number.isRequired,

	scrollIntoViewDelay: _propTypes2.default.number.isRequired,

	getTogglerNode: _propTypes2.default.func,
	onFocusOut: _propTypes2.default.func,
	onTapOutside: _propTypes2.default.func,

	// `aria-label` for the "Close" button
	// (which is an "x" visible in fullscreen mode).
	closeLabel: _propTypes2.default.string,

	// The "x" button icon that closes the `<Select/>`
	// in fullscreen mode on mobile devices.
	closeButtonIcon: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.oneOf([false])]).isRequired
}, _class.defaultProps = {
	scrollIntoView: true,
	expandAnimationDuration: 150,
	scrollIntoViewDelay: 0,

	// The "x" button icon that closes the `<Select/>`
	// in fullscreen mode on mobile devices.
	closeButtonIcon: _Close.CloseIcon
}, _temp2);
exports.default = Expandable;
//# sourceMappingURL=Expandable.js.map