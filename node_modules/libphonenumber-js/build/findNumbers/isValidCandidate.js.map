{"version":3,"sources":["../../source/findNumbers/isValidCandidate.js"],"names":["isValidCandidate","OPENING_PARENS","CLOSING_PARENS","NON_PARENS","LEAD_CLASS","LEAD_CLASS_LEADING","RegExp","BRACKET_PAIR_LIMIT","MATCHING_BRACKETS_ENTIRE","PUB_PAGES","candidate","offset","text","leniency","test","previousChar","lastCharIndex","length","nextChar"],"mappings":";;;;;;kBA6DwBA,gB;;AA3DxB;;AAMA;;AAMA;;AAOA,IAAMC,iBAAiB,kBAAvB,C,CArBA;;AAsBA,IAAMC,iBAAiB,kBAAvB;AACA,IAAMC,oBAAkBF,cAAlB,GAAmCC,cAAnC,MAAN;;AAEO,IAAME,wCAAiBH,cAAjB,2BAAN;;AAEP;AACA,IAAMI,qBAAqB,IAAIC,MAAJ,CAAW,MAAMF,UAAjB,CAA3B;;AAEA;AACA,IAAMG,qBAAqB,iBAAM,CAAN,EAAS,CAAT,CAA3B;;AAEA;;;;;;;;;AASA,IAAMC,2BAA2B,IAAIF,MAAJ,CAEhC,MACE,MADF,GACWL,cADX,GAC4B,KAD5B,GACoC,KADpC,GAC4CE,UAD5C,GACyD,GADzD,GAC+D,GAD/D,GACqED,cADrE,GACsF,KADtF,GAEEC,UAFF,GAEe,GAFf,GAGE,MAHF,GAGWF,cAHX,GAG4B,GAH5B,GAGkCE,UAHlC,GAG+C,IAH/C,GAGsDD,cAHtD,GAGuE,IAHvE,GAG8EK,kBAH9E,GAIEJ,UAJF,GAIe,GAJf,GAKE,GAP8B,CAAjC;;AAUA;;;;;;;AAOA,IAAMM,YAAY,kCAAlB;;AAEe,SAAST,gBAAT,CAA0BU,SAA1B,EAAqCC,MAArC,EAA6CC,IAA7C,EAAmDC,QAAnD,EACf;AACC;AACA;AACA,KAAI,CAACL,yBAAyBM,IAAzB,CAA8BJ,SAA9B,CAAD,IAA6CD,UAAUK,IAAV,CAAeJ,SAAf,CAAjD,EAA4E;AAC3E;AACA;;AAED;AACA;AACA,KAAIG,aAAa,UAAjB,EACA;AACC;AACA;AACA;AACA,MAAIF,SAAS,CAAT,IAAc,CAACN,mBAAmBS,IAAnB,CAAwBJ,SAAxB,CAAnB,EACA;AACC,OAAMK,eAAeH,KAAKD,SAAS,CAAd,CAArB;AACA;AACA,OAAI,qCAA2BI,YAA3B,KAA4C,wBAAcA,YAAd,CAAhD,EAA6E;AAC5E,WAAO,KAAP;AACA;AACD;;AAED,MAAMC,gBAAgBL,SAASD,UAAUO,MAAzC;AACA,MAAID,gBAAgBJ,KAAKK,MAAzB,EACA;AACC,OAAMC,WAAWN,KAAKI,aAAL,CAAjB;AACA,OAAI,qCAA2BE,QAA3B,KAAwC,wBAAcA,QAAd,CAA5C,EAAqE;AACpE,WAAO,KAAP;AACA;AACD;AACD;;AAED,QAAO,IAAP;AACA","file":"isValidCandidate.js","sourcesContent":["// Copy-pasted from `PhoneNumberMatcher.js`.\r\n\r\nimport\r\n{\r\n\tPLUS_CHARS\r\n}\r\nfrom '../common'\r\n\r\nimport\r\n{\r\n\tlimit\r\n}\r\nfrom './util'\r\n\r\nimport\r\n{\r\n\tisLatinLetter,\r\n\tisInvalidPunctuationSymbol\r\n}\r\nfrom './utf-8'\r\n\r\nconst OPENING_PARENS = '(\\\\[\\uFF08\\uFF3B'\r\nconst CLOSING_PARENS = ')\\\\]\\uFF09\\uFF3D'\r\nconst NON_PARENS = `[^${OPENING_PARENS}${CLOSING_PARENS}]`\r\n\r\nexport const LEAD_CLASS = `[${OPENING_PARENS}${PLUS_CHARS}]`\r\n\r\n// Punctuation that may be at the start of a phone number - brackets and plus signs.\r\nconst LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS)\r\n\r\n// Limit on the number of pairs of brackets in a phone number.\r\nconst BRACKET_PAIR_LIMIT = limit(0, 3)\r\n\r\n/**\r\n * Pattern to check that brackets match. Opening brackets should be closed within a phone number.\r\n * This also checks that there is something inside the brackets. Having no brackets at all is also\r\n * fine.\r\n *\r\n * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's\r\n * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a\r\n * closing bracket first. We limit the sets of brackets in a phone number to four.\r\n */\r\nconst MATCHING_BRACKETS_ENTIRE = new RegExp\r\n(\r\n\t'^'\r\n\t+ \"(?:[\" + OPENING_PARENS + \"])?\" + \"(?:\" + NON_PARENS + \"+\" + \"[\" + CLOSING_PARENS + \"])?\"\r\n\t+ NON_PARENS + \"+\"\r\n\t+ \"(?:[\" + OPENING_PARENS + \"]\" + NON_PARENS + \"+[\" + CLOSING_PARENS + \"])\" + BRACKET_PAIR_LIMIT\r\n\t+ NON_PARENS + \"*\"\r\n\t+ '$'\r\n)\r\n\r\n/**\r\n * Matches strings that look like publication pages. Example:\r\n * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.\r\n * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>\r\n *\r\n * The string \"211-227 (2003)\" is not a telephone number.\r\n */\r\nconst PUB_PAGES = /\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}/\r\n\r\nexport default function isValidCandidate(candidate, offset, text, leniency)\r\n{\r\n\t// Check the candidate doesn't contain any formatting\r\n\t// which would indicate that it really isn't a phone number.\r\n\tif (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded\r\n\t// by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.\r\n\tif (leniency !== 'POSSIBLE')\r\n\t{\r\n\t\t// If the candidate is not at the start of the text,\r\n\t\t// and does not start with phone-number punctuation,\r\n\t\t// check the previous character.\r\n\t\tif (offset > 0 && !LEAD_CLASS_LEADING.test(candidate))\r\n\t\t{\r\n\t\t\tconst previousChar = text[offset - 1]\r\n\t\t\t// We return null if it is a latin letter or an invalid punctuation symbol.\r\n\t\t\tif (isInvalidPunctuationSymbol(previousChar) || isLatinLetter(previousChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst lastCharIndex = offset + candidate.length\r\n\t\tif (lastCharIndex < text.length)\r\n\t\t{\r\n\t\t\tconst nextChar = text[lastCharIndex]\r\n\t\t\tif (isInvalidPunctuationSymbol(nextChar) || isLatinLetter(nextChar)) {\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}"]}